{"ast":null,"code":"'use strict';\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7;\nmodule.exports = class SparseArray {\n  constructor() {\n    this._bitArrays = [];\n    this._data = [];\n    this._length = 0;\n    this._changedLength = false;\n    this._changedData = false;\n  }\n  set(index, value) {\n    let pos = this._internalPositionFor(index, false);\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos);\n        this._unsetBit(index);\n        this._changedLength = true;\n        this._changedData = true;\n      }\n    } else {\n      let needsSort = false;\n      if (pos === -1) {\n        pos = this._data.length;\n        this._setBit(index);\n        this._changedData = true;\n      } else {\n        needsSort = true;\n      }\n      this._setInternalPos(pos, index, value, needsSort);\n      this._changedLength = true;\n    }\n  }\n  unset(index) {\n    this.set(index, undefined);\n  }\n  get(index) {\n    this._sortData();\n    const pos = this._internalPositionFor(index, true);\n    if (pos === -1) {\n      return undefined;\n    }\n    return this._data[pos][1];\n  }\n  push(value) {\n    this.set(this.length, value);\n    return this.length;\n  }\n  get length() {\n    this._sortData();\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1];\n      this._length = last ? last[0] + 1 : 0;\n      this._changedLength = false;\n    }\n    return this._length;\n  }\n  forEach(iterator) {\n    let i = 0;\n    while (i < this.length) {\n      iterator(this.get(i), i, this);\n      i++;\n    }\n  }\n  map(iterator) {\n    let i = 0;\n    let mapped = new Array(this.length);\n    while (i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this);\n      i++;\n    }\n    return mapped;\n  }\n  reduce(reducer, initialValue) {\n    let i = 0;\n    let acc = initialValue;\n    while (i < this.length) {\n      const value = this.get(i);\n      acc = reducer(acc, value, i);\n      i++;\n    }\n    return acc;\n  }\n  find(finder) {\n    let i = 0,\n      found,\n      last;\n    while (i < this.length && !found) {\n      last = this.get(i);\n      found = finder(last);\n      i++;\n    }\n    return found ? last : undefined;\n  }\n  _internalPositionFor(index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate);\n    if (bytePos >= this._bitArrays.length) {\n      return -1;\n    }\n    const byte = this._bitArrays[bytePos];\n    const bitPos = index - bytePos * BITS_PER_BYTE;\n    const exists = (byte & 1 << bitPos) > 0;\n    if (!exists) {\n      return -1;\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);\n    const mask = ~(0xffffffff << bitPos + 1);\n    const bytePopCount = popCount(byte & mask);\n    const arrayPos = previousPopCount + bytePopCount - 1;\n    return arrayPos;\n  }\n  _bytePosFor(index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE);\n    const targetLength = bytePos + 1;\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0);\n    }\n    return bytePos;\n  }\n  _setBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n    this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;\n  }\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n    this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);\n  }\n  _setInternalPos(pos, index, value, needsSort) {\n    const data = this._data;\n    const elem = [index, value];\n    if (needsSort) {\n      this._sortData();\n      data[pos] = elem;\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem);\n        } else if (data[0][0] <= index) {\n          data.unshift(elem);\n        } else {\n          const randomIndex = Math.round(data.length / 2);\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));\n        }\n      } else {\n        this._data.push(elem);\n      }\n      this._changedData = true;\n      this._changedLength = true;\n    }\n  }\n  _unsetInternalPos(pos) {\n    this._data.splice(pos, 1);\n  }\n  _sortData() {\n    if (this._changedData) {\n      this._data.sort(sortInternal);\n    }\n    this._changedData = false;\n  }\n  bitField() {\n    const bytes = [];\n    let pendingBitsForResultingByte = 8;\n    let pendingBitsForNewByte = 0;\n    let resultingByte = 0;\n    let newByte;\n    const pending = this._bitArrays.slice();\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift();\n        pendingBitsForNewByte = 7;\n      }\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);\n      const mask = ~(0b11111111 << usingBits);\n      const masked = newByte & mask;\n      resultingByte |= masked << 8 - pendingBitsForResultingByte;\n      newByte = newByte >>> usingBits;\n      pendingBitsForNewByte -= usingBits;\n      pendingBitsForResultingByte -= usingBits;\n      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {\n        bytes.push(resultingByte);\n        resultingByte = 0;\n        pendingBitsForResultingByte = 8;\n      }\n    }\n\n    // remove trailing zeroes\n    for (var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i];\n      if (value === 0) {\n        bytes.pop();\n      } else {\n        break;\n      }\n    }\n    return bytes;\n  }\n  compactArray() {\n    this._sortData();\n    return this._data.map(valueOnly);\n  }\n};\nfunction popCountReduce(count, byte) {\n  return count + popCount(byte);\n}\nfunction popCount(_v) {\n  let v = _v;\n  v = v - (v >> 1 & 0x55555555); // reuse input as temporary\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\nfunction sortInternal(a, b) {\n  return a[0] - b[0];\n}\nfunction valueOnly(elem) {\n  return elem[1];\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}