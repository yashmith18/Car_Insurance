{"ast":null,"code":"import g from \"pino\";\nimport f from \"@walletconnect/sign-client\";\nimport { getSdkError as h, isValidArray as P } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions as w } from \"@walletconnect/logger\";\nimport { JsonRpcProvider as c } from \"@walletconnect/jsonrpc-provider\";\nimport p, { HttpConnection as I } from \"@walletconnect/jsonrpc-http-connection\";\nimport C from \"events\";\nfunction y(s) {\n  var t;\n  const e = (t = s[Object.keys(s)[0]]) == null ? void 0 : t.chains[0];\n  return [e.split(\":\")[0], e.split(\":\")[1]];\n}\nfunction r(s, t) {\n  let e;\n  return t.rpcMap && (e = t.rpcMap[O([s])]), e;\n}\nfunction O(s) {\n  return Number(s[0].split(\":\")[1]);\n}\nclass E {\n  constructor(t) {\n    this.name = \"eip155\", this.namespace = t.namespace, this.client = t.client, this.events = t.events, this.httpProviders = this.createHttpProviders(), this.chainId = this.getDefaultChainId();\n  }\n  async request(t) {\n    var e;\n    switch (t.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        {\n          const i = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : \"0x0\";\n          return this.setDefaultChain(parseInt(i, 16).toString()), null;\n        }\n      case \"eth_chainId\":\n        return this.getDefaultChainId();\n    }\n    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = parseInt(t), !this.httpProviders[t]) {\n      const i = e || r(`${this.name}:${t}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  createHttpProvider(t, e) {\n    const i = e || r(t, this.namespace);\n    return typeof i > \"u\" ? void 0 : new c(new I(i));\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return parseInt(t.split(\":\")[1]);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n}\nclass $ {\n  constructor(t) {\n    this.name = \"solana\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const i = e || r(`${this.name}:${t}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || r(t, this.namespace);\n    return typeof i > \"u\" ? void 0 : new c(new p(i));\n  }\n}\nclass q {\n  constructor(t) {\n    this.name = \"cosmos\", this.namespace = t.namespace, this.events = t.events, this.client = t.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(t) {\n    this.namespace = Object.assign(this.namespace, t);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const t = this.namespace.accounts;\n    return t ? t.filter(e => e.split(\":\")[1] === this.chainId.toString()).map(e => e.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const t = {};\n    return this.namespace.chains.forEach(e => {\n      t[e] = this.createHttpProvider(e);\n    }), t;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const t = this.namespace.chains[0];\n    if (!t) throw new Error(\"ChainId not found\");\n    return t.split(\":\")[1];\n  }\n  request(t) {\n    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);\n  }\n  getHttpProvider() {\n    const t = `${this.name}:${this.chainId}`,\n      e = this.httpProviders[t];\n    if (typeof e > \"u\") throw new Error(`JSON-RPC provider for ${t} not found`);\n    return e;\n  }\n  setDefaultChain(t, e) {\n    if (this.chainId = t, !this.httpProviders[t]) {\n      const i = e || r(`${this.name}:${t}`, this.namespace);\n      if (!i) throw new Error(`No RPC url provided for chainId: ${t}`);\n      this.setHttpProvider(t, i);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(t, e) {\n    const i = this.createHttpProvider(t, e);\n    i && (this.httpProviders[t] = i);\n  }\n  createHttpProvider(t, e) {\n    const i = e || r(t, this.namespace);\n    return typeof i > \"u\" ? void 0 : new c(new p(i));\n  }\n}\nconst d = \"error\",\n  b = \"wss://relay.walletconnect.com\",\n  H = \"wc\",\n  S = \"universal_provider\",\n  l = `${H}@${2}:${S}:`;\nvar N = Object.defineProperty,\n  A = Object.defineProperties,\n  D = Object.getOwnPropertyDescriptors,\n  u = Object.getOwnPropertySymbols,\n  j = Object.prototype.hasOwnProperty,\n  _ = Object.prototype.propertyIsEnumerable,\n  v = (s, t, e) => t in s ? N(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : s[t] = e,\n  m = (s, t) => {\n    for (var e in t || (t = {})) j.call(t, e) && v(s, e, t[e]);\n    if (u) for (var e of u(t)) _.call(t, e) && v(s, e, t[e]);\n    return s;\n  },\n  k = (s, t) => A(s, D(t));\nclass a {\n  constructor(t) {\n    this.events = new C(), this.rpcProviders = {}, this.providerOpts = t, this.logger = typeof t?.logger < \"u\" && typeof t?.logger != \"string\" ? t.logger : g(w({\n      level: t?.logger || d\n    }));\n  }\n  static async init(t) {\n    const e = new a(t);\n    return await e.initialize(), e;\n  }\n  async request(t, e) {\n    var i;\n    const [n, o] = this.validateChain(e);\n    return await this.getProvider(n).request({\n      request: m({}, t),\n      chainId: `${n}:${o}`,\n      topic: (i = this.session) == null ? void 0 : i.topic\n    });\n  }\n  sendAsync(t, e, i) {\n    this.request(t, i).then(n => e(null, n)).catch(n => e(n, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    return await this.requestAccounts();\n  }\n  async disconnect() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    await this.client.disconnect({\n      topic: this.session.topic,\n      reason: h(\"USER_DISCONNECTED\")\n    });\n  }\n  async connect(t) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    const {\n      namespaces: e\n    } = t;\n    return this.setNamespaces(e), this.createProviders(), await this.cleanupPendingPairings(), t.skipPairing === !0 ? void 0 : await this.pair(t.pairingTopic);\n  }\n  on(t, e) {\n    this.events.on(t, e);\n  }\n  once(t, e) {\n    this.events.once(t, e);\n  }\n  removeListener(t, e) {\n    this.events.removeListener(t, e);\n  }\n  off(t, e) {\n    this.events.off(t, e);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(t) {\n    const {\n      uri: e,\n      approval: i\n    } = await this.client.connect({\n      pairingTopic: t,\n      requiredNamespaces: this.namespaces\n    });\n    return e && (this.uri = e, this.events.emit(\"display_uri\", e)), this.session = await i(), this.onSessionUpdate(), this.session;\n  }\n  setDefaultChain(t, e) {\n    try {\n      const [i, n] = this.validateChain(t);\n      this.getProvider(i).setDefaultChain(n, e);\n    } catch (i) {\n      if (!/Please call connect/.test(i.message)) throw i;\n    }\n  }\n  async cleanupPendingPairings() {\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const t = this.client.pairing.getAll({\n      active: !1\n    });\n    P(t) && (await Promise.all([t.map(e => this.client.pairing.delete(e.topic, h(\"USER_DISCONNECTED\"))), t.map(e => this.client.core.relayer.unsubscribe(e.topic)), t.map(e => this.client.core.expirer.del(e.topic))]), this.logger.info(`Inactive pairings cleared: ${t.length}`));\n  }\n  async checkStorage() {\n    if (this.namespaces = (await this.client.core.storage.getItem(`${l}/namespaces`)) || {}, this.namespaces && this.createProviders(), this.client.session.length) {\n      const t = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[t]), this.onSessionUpdate();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await f.init({\n      logger: this.providerOpts.logger || d,\n      relayUrl: this.providerOpts.relayUrl || b,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      name: this.providerOpts.name\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    Object.keys(this.namespaces).forEach(t => {\n      switch (t) {\n        case \"eip155\":\n          this.rpcProviders[t] = new E({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[t] = new $({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[t] = new q({\n            client: this.client,\n            namespace: this.namespaces[t],\n            events: this.events\n          });\n          break;\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", t => {\n      this.events.emit(\"session_ping\", t);\n    }), this.client.on(\"session_event\", t => {\n      this.events.emit(\"session_event\", t);\n    }), this.client.on(\"session_update\", _ref => {\n      let {\n        topic: t,\n        params: e\n      } = _ref;\n      var i;\n      const {\n          namespaces: n\n        } = e,\n        o = (i = this.client) == null ? void 0 : i.session.get(t);\n      this.session = k(m({}, o), {\n        namespaces: n\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: t,\n        params: e\n      });\n    }), this.client.on(\"session_delete\", () => {\n      this.events.emit(\"session_delete\");\n    });\n  }\n  getProvider(t) {\n    if (!this.rpcProviders[t]) throw new Error(`Provider not found: ${t}`);\n    return this.rpcProviders[t];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(t => this.getProvider(t).updateNamespace(this.session.namespaces[t]));\n  }\n  setNamespaces(t) {\n    if (!t || !Object.keys(t).length) throw new Error(\"Namespaces must be not empty\");\n    this.client.core.storage.setItem(`${l}/namespaces`, t), this.namespaces = t;\n  }\n  validateChain(t) {\n    const [e, i] = t?.split(\":\") || [\"\", \"\"];\n    if (e && !Object.keys(this.namespaces).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);\n    return !e || !i ? y(this.namespaces) : [e, i];\n  }\n  async requestAccounts() {\n    const [t] = this.validateChain();\n    return await this.getProvider(t).requestAccounts();\n  }\n}\nconst R = a;\nexport { R as UniversalProvider, a as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}