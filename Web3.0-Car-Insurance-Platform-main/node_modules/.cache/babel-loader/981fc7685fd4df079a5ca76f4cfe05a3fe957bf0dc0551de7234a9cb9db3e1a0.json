{"ast":null,"code":"'use strict';\n\nconst isOptionObject = require('is-plain-obj');\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst {\n  propertyIsEnumerable\n} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n  value,\n  writable: true,\n  enumerable: true,\n  configurable: true\n});\nconst globalThis = this;\nconst defaultMergeOptions = {\n  concatArrays: false,\n  ignoreUndefined: false\n};\nconst getEnumerableOwnPropertyKeys = value => {\n  const keys = [];\n  for (const key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      keys.push(key);\n    }\n  }\n\n  /* istanbul ignore else  */\n  if (Object.getOwnPropertySymbols) {\n    const symbols = Object.getOwnPropertySymbols(value);\n    for (const symbol of symbols) {\n      if (propertyIsEnumerable.call(value, symbol)) {\n        keys.push(symbol);\n      }\n    }\n  }\n  return keys;\n};\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return cloneArray(value);\n  }\n  if (isOptionObject(value)) {\n    return cloneOptionObject(value);\n  }\n  return value;\n}\nfunction cloneArray(array) {\n  const result = array.slice(0, 0);\n  getEnumerableOwnPropertyKeys(array).forEach(key => {\n    defineProperty(result, key, clone(array[key]));\n  });\n  return result;\n}\nfunction cloneOptionObject(object) {\n  const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n  getEnumerableOwnPropertyKeys(object).forEach(key => {\n    defineProperty(result, key, clone(object[key]));\n  });\n  return result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n  keys.forEach(key => {\n    if (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n      return;\n    }\n\n    // Do not recurse into prototype chain of merged\n    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n      defineProperty(merged, key, merge(merged[key], source[key], config));\n    } else {\n      defineProperty(merged, key, clone(source[key]));\n    }\n  });\n  return merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n  let result = merged.slice(0, 0);\n  let resultIndex = 0;\n  [merged, source].forEach(array => {\n    const indices = [];\n\n    // `result.concat(array)` with cloning\n    for (let k = 0; k < array.length; k++) {\n      if (!hasOwnProperty.call(array, k)) {\n        continue;\n      }\n      indices.push(String(k));\n      if (array === merged) {\n        // Already cloned\n        defineProperty(result, resultIndex++, array[k]);\n      } else {\n        defineProperty(result, resultIndex++, clone(array[k]));\n      }\n    }\n\n    // Merge non-index keys\n    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n  });\n  return result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n  if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n    return concatArrays(merged, source, config);\n  }\n  if (!isOptionObject(source) || !isOptionObject(merged)) {\n    return clone(source);\n  }\n  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\nmodule.exports = function () {\n  const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);\n  let merged = {\n    _: {}\n  };\n  for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {\n    options[_key] = arguments[_key];\n  }\n  for (const option of options) {\n    if (option === undefined) {\n      continue;\n    }\n    if (!isOptionObject(option)) {\n      throw new TypeError('`' + option + '` is not an Option Object');\n    }\n    merged = merge(merged, {\n      _: option\n    }, config);\n  }\n  return merged._;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}