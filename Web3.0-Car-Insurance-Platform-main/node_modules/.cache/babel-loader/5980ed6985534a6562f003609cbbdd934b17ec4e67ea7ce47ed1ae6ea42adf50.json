{"ast":null,"code":"import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack(_ref) {\n  let {\n    input,\n    blockstore: userBlockstore,\n    hasher,\n    maxChunkSize,\n    maxChildrenPerNode,\n    wrapWithDirectory,\n    rawLeaves\n  } = _ref;\n  if (!input || Array.isArray(input) && !input.length) {\n    throw new Error('missing input file(s)');\n  }\n  const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n  // Consume the source\n  const rootEntry = await last(pipe(getNormaliser(input), source => importer(source, blockstore, {\n    ...unixfsImporterOptionsDefault,\n    hasher: hasher || unixfsImporterOptionsDefault.hasher,\n    maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n    maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n    wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n    rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n  })));\n  if (!rootEntry || !rootEntry.cid) {\n    throw new Error('given input could not be parsed correctly');\n  }\n  const root = rootEntry.cid;\n  const {\n    writer,\n    out: carOut\n  } = await CarWriter.create([root]);\n  const carOutIter = carOut[Symbol.asyncIterator]();\n  let writingPromise;\n  const writeAll = async () => {\n    for await (const block of blockstore.blocks()) {\n      // `await` will block until all bytes in `carOut` are consumed by the user\n      // so we have backpressure here\n      await writer.put(block);\n    }\n    await writer.close();\n    if (!userBlockstore) {\n      await blockstore.close();\n    }\n  };\n  const out = {\n    [Symbol.asyncIterator]() {\n      if (writingPromise != null) {\n        throw new Error('Multiple iterator not supported');\n      }\n      // don't start writing until the user starts consuming the iterator\n      writingPromise = writeAll();\n      return {\n        async next() {\n          const result = await carOutIter.next();\n          if (result.done) {\n            await writingPromise; // any errors will propagate from here\n          }\n\n          return result;\n        }\n      };\n    }\n  };\n  return {\n    root,\n    out\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}