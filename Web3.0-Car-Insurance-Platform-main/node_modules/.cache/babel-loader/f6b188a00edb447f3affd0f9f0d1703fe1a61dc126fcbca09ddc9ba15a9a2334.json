{"ast":null,"code":"import { BaseBlockstore } from './base.js';\nimport { base32 } from 'multiformats/bases/base32';\nimport * as raw from 'multiformats/codecs/raw';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as Errors from './errors.js';\nexport class MemoryBlockstore extends BaseBlockstore {\n  constructor() {\n    super();\n    this.data = {};\n  }\n  open() {\n    return Promise.resolve();\n  }\n  close() {\n    return Promise.resolve();\n  }\n  async put(key, val) {\n    this.data[base32.encode(key.multihash.bytes)] = val;\n  }\n  async get(key) {\n    const exists = await this.has(key);\n    if (!exists) throw Errors.notFoundError();\n    return this.data[base32.encode(key.multihash.bytes)];\n  }\n  async has(key) {\n    return this.data[base32.encode(key.multihash.bytes)] !== undefined;\n  }\n  async delete(key) {\n    delete this.data[base32.encode(key.multihash.bytes)];\n  }\n  async *_all() {\n    yield* Object.entries(this.data).map(_ref => {\n      let [key, value] = _ref;\n      return {\n        key: CID.createV1(raw.code, Digest.decode(base32.decode(key))),\n        value\n      };\n    });\n  }\n  async *_allKeys() {\n    yield* Object.entries(this.data).map(_ref2 => {\n      let [key] = _ref2;\n      return CID.createV1(raw.code, Digest.decode(base32.decode(key)));\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}