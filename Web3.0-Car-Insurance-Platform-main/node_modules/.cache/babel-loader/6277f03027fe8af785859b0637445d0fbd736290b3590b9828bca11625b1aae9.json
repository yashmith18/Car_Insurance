{"ast":null,"code":"async function* _batch(size, iterable) {\n  let dataBatch = [];\n  for await (const data of iterable) {\n    dataBatch.push(data);\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n  for (const data of iterable) {\n    dataBatch.push(data);\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n  return _syncBatch(size, iterable);\n}\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = duration => {\n  let timeoutId;\n  return [new Promise(resolve => {\n    timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n  }), () => {\n    clearTimeout(timeoutId);\n  }];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let pendingData;\n  let batchData = [];\n  let timer;\n  let clearTimer;\n  const startTimer = () => {\n    deleteTimer();\n    [timer, clearTimer] = createTimer(timeout);\n  };\n  const deleteTimer = () => {\n    if (clearTimer) {\n      clearTimer();\n    }\n    timer = undefined;\n  };\n  pendingData = iterator.next();\n  while (true) {\n    const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n    if (res === TIMEOUT || res.done) {\n      // Flush early (before we reach the batch size)\n      if (batchData.length) {\n        yield batchData;\n        batchData = [];\n      }\n      deleteTimer();\n      // And exit appropriately\n      if (res !== TIMEOUT) {\n        // done\n        break;\n      }\n      continue;\n    }\n    // Fetch next item early doors (before we potentially yield)\n    pendingData = iterator.next();\n    // Then handle the value\n    batchData.push(res.value);\n    if (batchData.length === 1) {\n      // Start timer once we have at least 1 item ready to go\n      startTimer();\n    }\n    if (batchData.length === size) {\n      yield batchData;\n      batchData = [];\n      deleteTimer();\n      continue;\n    }\n  }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n    return _batchWithTimeout(size, timeout, iterable);\n  }\n  // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n  return batch(size, iterable);\n}\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n}\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (resultQueue.length >= size) {\n      return;\n    }\n    reading = true;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n      if (error) {\n        throw error;\n      }\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n      if (valueQueue.length <= size) {\n        continue;\n      }\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n  for (const value of valueQueue) {\n    yield value;\n  }\n  if (e) {\n    throw e;\n  }\n}\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n  if (size === 0) {\n    return iterable;\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n  return syncBuffer(size, iterable);\n}\nasync function _collect(iterable) {\n  const values = [];\n  for await (const value of iterable) {\n    values.push(value);\n  }\n  return values;\n}\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n  return Array.from(iterable);\n}\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\nfunction concat() {\n  for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n    iterables[_key] = arguments[_key];\n  }\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\nasync function _consume(iterable) {\n  for await (const val of iterable) {\n    // do nothing\n  }\n}\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n  for (const val of iterable) {\n    // do nothing\n  }\n}\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n  return _filter(filterFunc, iterable);\n}\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n  return _map(func, iterable);\n}\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n    reading = true;\n    inflightCount++;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n    reading = false;\n    fillQueue();\n  }\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n    if (stream._readableState.ended) {\n      break;\n    }\n    await onceReadable(stream);\n  }\n}\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n  return _fromStream(stream);\n}\nasync function* merge() {\n  for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    iterables[_key2] = arguments[_key2];\n  }\n  const sources = new Set(iterables.map(getIterator));\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\nfunction pipeline(firstFn) {\n  let previousFn = firstFn();\n  for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    fns[_key3 - 1] = arguments[_key3];\n  }\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n  return previousFn;\n}\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n      yield value;\n    }\n  };\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n  while (true) {\n    const {\n      value,\n      done\n    } = await itr.next();\n    if (done) {\n      break;\n    }\n    try {\n      const val = await value.value;\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n  if (transformError) {\n    throw transformError;\n  }\n}\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n  return _parallelMap(concurrency, func, iterable);\n}\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\nasync function* parallelMerge() {\n  for (var _len4 = arguments.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    iterables[_key4] = arguments[_key4];\n  }\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n  const notifyError = err => {\n    lastError = err;\n    if (errCb) {\n      errCb(err);\n    }\n  };\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n    if (values.size > 0) {\n      return resolve();\n    }\n    valueCb = resolve;\n    errCb = reject;\n  });\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async _ref => {\n      let {\n        done,\n        value\n      } = _ref;\n      if (!done) {\n        values.set(input, value);\n      }\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n  for (const input of inputs) {\n    queueNext(input);\n  }\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n    await waitForQueue();\n    for (const [input, value] of values) {\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\nasync function _reduce(func, start, iterable) {\n  let value = start;\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n  return value;\n}\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n  return _reduce(func, start, iterable);\n}\nasync function* _take(count, iterable) {\n  let taken = 0;\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n    if (taken >= count) {\n      break;\n    }\n  }\n}\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n  for (const val of iterable) {\n    yield val;\n    taken++;\n    if (taken >= count) {\n      break;\n    }\n  }\n}\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n  return _syncTake(count, iterable);\n}\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n  return _asyncTap(func, iterable);\n}\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n  if (limit <= 0) {\n    throw new TypeError('Expected `limit` to be greater than 0');\n  }\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n  return async function* __throttle() {\n    let sent = 0;\n    let time;\n    for await (const val of iterable) {\n      if (sent < limit) {\n        if (typeof time === 'undefined') {\n          time = Date.now();\n        }\n        sent++;\n        yield val;\n        continue;\n      }\n      // Only wait if the interval hasn't already passed while we were\n      // yielding the previous values.\n      const elapsedMs = Date.now() - time;\n      const waitFor = interval - elapsedMs;\n      if (waitFor > 0) {\n        await sleep(waitFor);\n      }\n      time = Date.now();\n      sent = 1;\n      yield val;\n    }\n  }();\n}\nfunction throttle(limit, interval, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _throttle(limit, interval, curriedIterable);\n  }\n  return _throttle(limit, interval, iterable);\n}\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n  return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = await itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n      return value;\n    }\n    yield value;\n  }\n}\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n      return value;\n    }\n    yield value;\n  }\n}\nfunction time() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let iterable = arguments.length > 1 ? arguments[1] : undefined;\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n    reading = true;\n    inflightCount++;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n    reading = false;\n    fillQueue();\n  }\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n  return _transform(concurrency, func, iterable);\n}\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n  const notifyError = err => {\n    lastError = err;\n    if (errCb) {\n      errCb(err);\n    }\n  };\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n  stream.once('error', notifyError);\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n    if (lastError) {\n      break;\n    }\n  }\n  cleanup();\n  if (lastError) {\n    throw lastError;\n  }\n}\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n  return _writeToStream(stream, iterable);\n}\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}