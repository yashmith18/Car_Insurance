{"ast":null,"code":"import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = function () {\n  let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\nexport function walkPath(path, blockstore) {\n  try {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return async function* () {\n      let {\n        cid,\n        toResolve\n      } = cidAndRest(path);\n      let name = cid.toString();\n      let entryPath = name;\n      const startingDepth = toResolve.length;\n      while (true) {\n        const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n        if (!result.entry && !result.next) {\n          throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n        }\n        if (result.entry) {\n          yield result.entry;\n        }\n        if (!result.next) {\n          return;\n        }\n        toResolve = result.next.toResolve;\n        cid = result.next.cid;\n        name = result.next.name;\n        entryPath = result.next.path;\n      }\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\nexport async function exporter(path, blockstore) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport function recursive(path, blockstore) {\n  try {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return async function* () {\n      const node = await exporter(path, blockstore, options);\n      if (!node) {\n        return;\n      }\n      yield node;\n      if (node.type === 'directory') {\n        for await (const child of recurse(node, options)) {\n          yield child;\n        }\n      }\n      async function* recurse(node, options) {\n        for await (const file of node.content(options)) {\n          yield file;\n          if (file instanceof Uint8Array) {\n            continue;\n          }\n          if (file.type === 'directory') {\n            yield* recurse(file, options);\n          }\n        }\n      }\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}