{"ast":null,"code":"import { Connector, __privateAdd, __privateGet, __privateMethod, __privateSet, __publicField } from \"./chunk-5NCTPR6C.js\";\n\n// src/walletConnect.ts\nimport { SwitchChainError, UserRejectedRequestError, getClient, normalizeChainId } from \"@wagmi/core\";\nimport { providers } from \"ethers\";\nimport { getAddress, hexValue } from \"ethers/lib/utils.js\";\nvar defaultV2Config = {\n  namespace: \"eip155\",\n  methods: [\"eth_sendTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"personal_sign\"],\n  events: [\"accountsChanged\", \"chainChanged\"]\n};\nvar _provider, _universalProviderPromise, _web3Modal, _createWeb3Modal, createWeb3Modal_fn, _getUniversalProvider, getUniversalProvider_fn, _isChainsAuthorized, isChainsAuthorized_fn, _switchChain, switchChain_fn;\nvar WalletConnectConnector = class extends Connector {\n  constructor(config) {\n    super(config);\n    __privateAdd(this, _createWeb3Modal);\n    __privateAdd(this, _getUniversalProvider);\n    __privateAdd(this, _isChainsAuthorized);\n    __privateAdd(this, _switchChain);\n    __publicField(this, \"id\", \"walletConnect\");\n    __publicField(this, \"name\", \"WalletConnect\");\n    __publicField(this, \"ready\", true);\n    __privateAdd(this, _provider, void 0);\n    __privateAdd(this, _universalProviderPromise, void 0);\n    __privateAdd(this, _web3Modal, void 0);\n    __publicField(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit(\"disconnect\");else this.emit(\"change\", {\n        account: getAddress(accounts[0])\n      });\n    });\n    __publicField(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    __publicField(this, \"onDisconnect\", () => {\n      this.emit(\"disconnect\");\n    });\n    __publicField(this, \"onDisplayUri\", uri => {\n      this.emit(\"message\", {\n        type: \"display_uri\",\n        data: uri\n      });\n    });\n    if (this.version === \"2\") {\n      __privateMethod(this, _getUniversalProvider, getUniversalProvider_fn).call(this);\n      if (this.isQrCode) __privateMethod(this, _createWeb3Modal, createWeb3Modal_fn).call(this);\n    }\n  }\n  get isQrCode() {\n    return this.options.qrcode !== false;\n  }\n  get namespacedChains() {\n    return this.chains.map(chain => `${defaultV2Config.namespace}:${chain.id}`);\n  }\n  get version() {\n    if (\"version\" in this.options) return this.options.version;\n    return \"1\";\n  }\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const isV1 = this.version === \"1\";\n    const isV2 = this.version === \"2\";\n    try {\n      let targetChainId = chainId;\n      if (!targetChainId) {\n        const lastUsedChainId = getClient().lastUsedChainId;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;\n      }\n      const provider = await this.getProvider({\n        chainId: targetChainId,\n        create: isV1\n      });\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n      if (isV2) {\n        provider.on(\"session_delete\", this.onDisconnect);\n        provider.on(\"display_uri\", this.onDisplayUri);\n        const isChainsAuthorized = await __privateMethod(this, _isChainsAuthorized, isChainsAuthorized_fn).call(this);\n        if (provider.session && !isChainsAuthorized) await provider.disconnect();\n        if (!provider.session || provider.session && !isChainsAuthorized) {\n          await Promise.race([provider.connect({\n            namespaces: {\n              [defaultV2Config.namespace]: {\n                methods: defaultV2Config.methods,\n                events: defaultV2Config.events,\n                chains: this.namespacedChains,\n                rpcMap: this.chains.reduce((rpc, chain) => ({\n                  ...rpc,\n                  [chain.id]: chain.rpcUrls.default.http[0]\n                }), {})\n              }\n            }\n          }), ...(this.isQrCode ? [new Promise((_resolve, reject) => provider.on(\"display_uri\", async uri => {\n            await __privateGet(this, _web3Modal)?.openModal({\n              uri\n            });\n            __privateGet(this, _web3Modal)?.subscribeModal(_ref => {\n              let {\n                open\n              } = _ref;\n              if (!open) reject(new Error(\"user rejected\"));\n            });\n          }))] : [])]);\n          if (this.isQrCode) __privateGet(this, _web3Modal)?.closeModal();\n        }\n      }\n      setTimeout(() => this.emit(\"message\", {\n        type: \"connecting\"\n      }), 0);\n      const accounts = await Promise.race([provider.enable(), ...(isV1 && this.isQrCode ? [new Promise((_res, reject) => provider.connector.on(\"disconnect\", () => reject(new Error(\"user rejected\"))))] : [])]);\n      const account = getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id);\n      if (isV1) {\n        const walletName = provider.connector?.peerMeta?.name ?? \"\";\n        const switchChainAllowedRegex = /(imtoken|metamask|omni|rainbow|trust wallet)/i;\n        if (switchChainAllowedRegex.test(walletName)) this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);\n      } else this.switchChain = __privateMethod(this, _switchChain, switchChain_fn);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (isV2 && this.isQrCode) __privateGet(this, _web3Modal)?.closeModal();\n      if (/user closed modal|user rejected/i.test(error?.message)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw error;\n    }\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    try {\n      await provider.disconnect();\n    } catch (error) {\n      if (!/No matching key/i.test(error.message)) throw error;\n    }\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n    if (this.version === \"1\" && typeof localStorage !== \"undefined\") localStorage.removeItem(\"walletconnect\");else {\n      provider.removeListener(\"session_delete\", this.onDisconnect);\n      provider.removeListener(\"display_uri\", this.onDisplayUri);\n    }\n  }\n  async getAccount() {\n    const provider = await this.getProvider();\n    let accounts;\n    if (this.version === \"1\") accounts = provider.accounts;else accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n    return getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (this.version === \"1\") return normalizeChainId(provider.chainId);\n    return getClient().data?.chain?.id ?? normalizeChainId(await provider.request({\n      method: \"eth_chainId\"\n    }));\n  }\n  async getProvider() {\n    let {\n      chainId,\n      create\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this.options.version === \"2\") {\n      if (!__privateGet(this, _provider) || create) __privateSet(this, _provider, await __privateMethod(this, _getUniversalProvider, getUniversalProvider_fn).call(this));\n      if (chainId) __privateGet(this, _provider).setDefaultChain(`${defaultV2Config.namespace}:${chainId}`);\n      return __privateGet(this, _provider);\n    } else if (!__privateGet(this, _provider) || chainId || create) {\n      const rpc = !this.options?.infuraId ? this.chains.reduce((rpc2, chain) => ({\n        ...rpc2,\n        [chain.id]: chain.rpcUrls.default.http[0]\n      }), {}) : {};\n      const WalletConnectProvider = (await import(\"@walletconnect/ethereum-provider\")).default;\n      __privateSet(this, _provider, new WalletConnectProvider({\n        ...this.options,\n        chainId,\n        rpc: {\n          ...rpc,\n          ...this.options?.rpc\n        }\n      }));\n      return __privateGet(this, _provider);\n    }\n    return __privateGet(this, _provider);\n  }\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    let provider_ = provider;\n    if (this.version === \"2\") {\n      const chainId_ = await this.getChainId();\n      provider_ = {\n        ...provider,\n        async request(args) {\n          return await provider.request(args, `${defaultV2Config.namespace}:${chainId ?? chainId_}`);\n        }\n      };\n    }\n    return new providers.Web3Provider(provider_, chainId).getSigner(account);\n  }\n  async isAuthorized() {\n    try {\n      const [account, isChainsAuthorized] = await Promise.all([this.getAccount(), __privateMethod(this, _isChainsAuthorized, isChainsAuthorized_fn).call(this)]);\n      return !!account && isChainsAuthorized;\n    } catch {\n      return false;\n    }\n  }\n};\n_provider = new WeakMap();\n_universalProviderPromise = new WeakMap();\n_web3Modal = new WeakMap();\n_createWeb3Modal = new WeakSet();\ncreateWeb3Modal_fn = async function () {\n  const {\n    Web3Modal\n  } = await import(\"@web3modal/standalone\");\n  const {\n    version\n  } = this.options;\n  __privateSet(this, _web3Modal, new Web3Modal({\n    projectId: version === \"2\" ? this.options.projectId : void 0,\n    standaloneChains: this.namespacedChains\n  }));\n};\n_getUniversalProvider = new WeakSet();\ngetUniversalProvider_fn = async function () {\n  if (!__privateGet(this, _universalProviderPromise)) {\n    const WalletConnectProvider = (await import(\"@walletconnect/universal-provider\")).default;\n    __privateSet(this, _universalProviderPromise, WalletConnectProvider.init(this.options));\n  }\n  return __privateGet(this, _universalProviderPromise);\n};\n_isChainsAuthorized = new WeakSet();\nisChainsAuthorized_fn = async function () {\n  const provider = await this.getProvider();\n  if (this.version === \"1\") return true;\n  const providerChains = provider.namespaces?.[defaultV2Config.namespace]?.chains || [];\n  const authorizedChainIds = providerChains.map(chain => parseInt(chain.split(\":\")[1] || \"\"));\n  return !this.chains.some(_ref2 => {\n    let {\n      id\n    } = _ref2;\n    return !authorizedChainIds.includes(id);\n  });\n};\n_switchChain = new WeakSet();\nswitchChain_fn = async function (chainId) {\n  const provider = await this.getProvider();\n  const id = hexValue(chainId);\n  try {\n    await Promise.race([provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: id\n      }]\n    }), new Promise(res => this.on(\"change\", _ref3 => {\n      let {\n        chain\n      } = _ref3;\n      if (chain?.id === chainId) res(chainId);\n    }))]);\n    if (this.version === \"2\") {\n      ;\n      provider.setDefaultChain(`${defaultV2Config.namespace}:${chainId}`);\n      this.onChainChanged(chainId);\n    }\n    return this.chains.find(x => x.id === chainId) ?? {\n      id: chainId,\n      name: `Chain ${id}`,\n      network: `${id}`,\n      nativeCurrency: {\n        decimals: 18,\n        name: \"Ether\",\n        symbol: \"ETH\"\n      },\n      rpcUrls: {\n        default: {\n          http: [\"\"]\n        },\n        public: {\n          http: [\"\"]\n        }\n      }\n    };\n  } catch (error) {\n    const message = typeof error === \"string\" ? error : error?.message;\n    if (/user rejected request/i.test(message)) throw new UserRejectedRequestError(error);\n    throw new SwitchChainError(error);\n  }\n};\nexport { WalletConnectConnector };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}