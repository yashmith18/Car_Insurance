{"ast":null,"code":"'use strict';\n\n// @ts-ignore\nconst SparseArray = require('sparse-array');\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor(options, parent) {\n    let posAtParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray();\n\n    /** @type {string | null} */\n    this.key = null;\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get(key) {\n    const child = await this._findChild(key);\n    if (child) {\n      return child.value;\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del(key) {\n    const place = await this._findPlace(key);\n    const child = place.bucket._at(place.pos);\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount() {\n    const children = this._children.compactArray();\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n      return acc + 1;\n    }, 0);\n  }\n  childrenCount() {\n    return this._children.length;\n  }\n  onlyChild() {\n    return this._children.get(0);\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return [];\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize(map, reduce) {\n    /** @type {T[]} */\n    const acc = [];\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n      return acc;\n    }, acc));\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n    const child = result.bucket._at(result.pos);\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined;\n    }\n    if (child && child.key === key) {\n      return child;\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace(key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n    const index = await hashValue.take(this._options.bits);\n    const child = this._children.get(index);\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue);\n    }\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    };\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n      place.bucket._putObjectAt(place.pos, bucket);\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash);\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n      return bucket._findNewBucketAndPos(place.hash);\n    }\n\n    // no conflict, we found the place\n    return place;\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n    this._children.set(pos, object);\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n    this._children.unset(pos);\n    this._level();\n  }\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at(index) {\n    return this._children.get(index);\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists(o) {\n  return Boolean(o);\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode(node, index) {\n  return node.key;\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n  }\n  return asyncReduce(output);\n}\nmodule.exports = Bucket;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}