{"ast":null,"code":"import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nfunction emitBytes(blockstore, node, start, end) {\n  try {\n    let streamPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let options = arguments.length > 5 ? arguments[5] : undefined;\n    return async function* () {\n      if (node instanceof Uint8Array) {\n        const buf = extractDataFromBlock(node, streamPosition, start, end);\n        if (buf.length) {\n          yield buf;\n        }\n        streamPosition += buf.length;\n        return streamPosition;\n      }\n      if (node.Data == null) {\n        throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n      }\n      let file;\n      try {\n        file = UnixFS.unmarshal(node.Data);\n      } catch (err) {\n        throw errCode(err, 'ERR_NOT_UNIXFS');\n      }\n      if (file.data && file.data.length) {\n        const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n        if (buf.length) {\n          yield buf;\n        }\n        streamPosition += file.data.length;\n      }\n      let childStart = streamPosition;\n      for (let i = 0; i < node.Links.length; i++) {\n        const childLink = node.Links[i];\n        const childEnd = streamPosition + file.blockSizes[i];\n        if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n          const block = await blockstore.get(childLink.Hash, {\n            signal: options.signal\n          });\n          let child;\n          switch (childLink.Hash.code) {\n            case dagPb.code:\n              child = await dagPb.decode(block);\n              break;\n            case raw.code:\n              child = block;\n              break;\n            case dagCbor.code:\n              child = await dagCbor.decode(block);\n              break;\n            default:\n              throw Error(`Unsupported codec: ${childLink.Hash.code}`);\n          }\n          for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n            streamPosition += buf.length;\n            yield buf;\n          }\n        }\n        streamPosition = childEnd;\n        childStart = childEnd + 1;\n      }\n    }();\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}