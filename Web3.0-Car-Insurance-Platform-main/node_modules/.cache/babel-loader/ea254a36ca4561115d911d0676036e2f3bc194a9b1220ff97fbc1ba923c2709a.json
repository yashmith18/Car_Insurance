{"ast":null,"code":"/**\n * @license\n * [BSD-3-Clause](https://github.com/pryv/unix-timestamp-js/blob/master/LICENSE)\n */\n/**\n * Tiny library to create and manipulate Unix timestamps\n * (i.e. defined as the number of seconds since Unix epoch time).\n */\n\nconst timestamp = module.exports = {};\n\n// constants\n\ntimestamp.Millisecond = 0.001;\ntimestamp.Second = 1;\ntimestamp.Minute = 60;\ntimestamp.Hour = 60 * timestamp.Minute;\ntimestamp.Day = 24 * timestamp.Hour;\ntimestamp.Week = 7 * timestamp.Day;\n/**\n * = mean Gregorian month\n */\ntimestamp.Month = 30.436875 * timestamp.Day;\ntimestamp.Year = 12 * timestamp.Month;\nconst OffsetRegExp = new RegExp('^\\\\s*' + '([-+]?)\\\\s*' + ['y', 'M', 'w', 'd', 'h', 'm', 's', 'ms'].map(function (t) {\n  return '(?:(\\\\d+)\\\\s*' + t + ')?';\n}).join('\\\\s*') + '\\\\s*$');\nlet outputFn = dontRound;\nfunction dontRound(time) {\n  return time;\n}\nfunction round(time) {\n  return Math.round(time);\n}\n/**\n * Set to `true` to round all returned timestamps to the second. Defaults to `false`.\n */\nObject.defineProperty(timestamp, 'round', {\n  get: function () {\n    return outputFn === round;\n  },\n  set: function (value) {\n    outputFn = value ? round : dontRound;\n  }\n});\n\n/**\n * Gets the current time as Unix timestamp.\n * Optionally applying a given offset specified as either a human-readable string or a number of\n * seconds.\n *\n * @param {String|Number} offset The optional time offset to apply\n * @returns {Number} The corresponding timestamp\n */\ntimestamp.now = function (offset) {\n  const now = Date.now() / 1000;\n  return outputFn(offset ? timestamp.add(now, offset) : now);\n};\n\n/**\n * Applies the given offset to the given timestamp.\n * The offset is specified as either a human-readable string or a number of\n * seconds.\n *\n * @param {Number} time The original timestamp\n * @param {String|Number} offset The time offset to apply\n * @returns {Number} The result timestamp\n */\ntimestamp.add = function (time, offset) {\n  if (!isNumber(time)) {\n    throw new Error('Time must be a number');\n  }\n  if (isString(offset)) {\n    const matches = OffsetRegExp.exec(offset);\n    if (!matches) {\n      throw new Error('Expected offset string format: [+|-] [{years}y] [{months}M] [{weeks}w] ' + '[{days}d] [{hours}h] [{minutes}m] [{seconds}s] [{milliseconds}ms]');\n    }\n    offset = (matches[1] === '-' ? -1 : 1) * ((matches[2] || 0) * timestamp.Year + (matches[3] || 0) * timestamp.Month + (matches[4] || 0) * timestamp.Week + (matches[5] || 0) * timestamp.Day + (matches[6] || 0) * timestamp.Hour + (matches[7] || 0) * timestamp.Minute + (matches[8] || 0) * timestamp.Second + (matches[9] || 0) * timestamp.Millisecond);\n  } else if (!isNumber(offset)) {\n    throw new Error('Offset must be either a string or a number');\n  }\n  return outputFn(time + offset);\n};\n\n/**\n * Gets the offset timestamp for the given offset string.\n * (Alias for .add() using a time of zero.)\n *\n * @param {String|Number} offset The time offset for the duration\n * @returns {Number} The result time offset\n */\ntimestamp.duration = function (offset) {\n  return timestamp.add(0, offset);\n};\n\n/**\n * Gets the Unix timestamp for the given date object or string.\n *\n * @param {Date|String} date A date object or an ISO 8601 date string\n * @returns {Number} The corresponding timestamp\n */\ntimestamp.fromDate = function (date) {\n  if (isString(date)) {\n    date = new Date(date);\n  } else if (!isDate(date)) {\n    throw new Error('Expected either a string or a date');\n  }\n  return outputFn(date.getTime() / 1000);\n};\n\n/**\n * Gets the date for the given Unix timestamp.\n *\n * @param {Number} time A timestamp\n * @returns {Date} The corresponding date\n */\ntimestamp.toDate = function (time) {\n  if (!isNumber(time)) {\n    throw new Error('Expected a number');\n  }\n  return new Date(time * 1000);\n};\nfunction isString(value) {\n  return typeof value === 'string' || Object.prototype.toString.call(value) === '[object String]';\n}\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\nfunction isDate(value) {\n  return Object.prototype.toString.call(value) === '[object Date]';\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}