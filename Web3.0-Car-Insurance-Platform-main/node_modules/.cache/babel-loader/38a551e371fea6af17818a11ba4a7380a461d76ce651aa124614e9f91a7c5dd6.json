{"ast":null,"code":"import { InjectedConnector } from \"./chunk-BVC4KGLQ.js\";\nimport { __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-MQXBDTVK.js\";\n\n// src/utils/configureChains.ts\nimport { providers } from \"ethers\";\nfunction configureChains(defaultChains, providers2) {\n  let {\n    minQuorum = 1,\n    pollingInterval = 4e3,\n    targetQuorum = 1,\n    stallTimeout\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!defaultChains.length) throw new Error(\"must have at least one chain\");\n  if (targetQuorum < minQuorum) throw new Error(\"quorum cannot be lower than minQuorum\");\n  let chains = [];\n  const providers_ = {};\n  const webSocketProviders_ = {};\n  for (const chain of defaultChains) {\n    let configExists = false;\n    for (const provider of providers2) {\n      const apiConfig = provider(chain);\n      if (!apiConfig) continue;\n      configExists = true;\n      if (!chains.some(_ref => {\n        let {\n          id\n        } = _ref;\n        return id === chain.id;\n      })) {\n        chains = [...chains, apiConfig.chain];\n      }\n      providers_[chain.id] = [...(providers_[chain.id] || []), apiConfig.provider];\n      if (apiConfig.webSocketProvider) {\n        webSocketProviders_[chain.id] = [...(webSocketProviders_[chain.id] || []), apiConfig.webSocketProvider];\n      }\n    }\n    if (!configExists) {\n      throw new Error([`Could not find valid provider configuration for chain \"${chain.name}\".\n`, \"You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.\", \"Read more: https://wagmi.sh/react/providers/jsonRpc\"].join(\"\\n\"));\n    }\n  }\n  return {\n    chains,\n    provider: _ref2 => {\n      let {\n        chainId\n      } = _ref2;\n      const activeChain = chains.find(x => x.id === chainId) ?? defaultChains[0];\n      const chainProviders = providers_[activeChain.id];\n      if (!chainProviders || !chainProviders[0]) throw new Error(`No providers configured for chain \"${activeChain.id}\"`);\n      let provider;\n      if (chainProviders.length === 1) {\n        provider = chainProviders[0]();\n      } else {\n        provider = fallbackProvider(targetQuorum, minQuorum, chainProviders, {\n          stallTimeout\n        });\n      }\n      if (activeChain.id === 42220) {\n        provider.formatter.formats.block = {\n          ...provider.formatter.formats.block,\n          difficulty: () => 0,\n          gasLimit: () => 0\n        };\n      }\n      return Object.assign(provider, {\n        chains,\n        pollingInterval\n      });\n    },\n    webSocketProvider: _ref3 => {\n      let {\n        chainId\n      } = _ref3;\n      const activeChain = chains.find(x => x.id === chainId) ?? defaultChains[0];\n      const chainWebSocketProviders = webSocketProviders_[activeChain.id];\n      if (!chainWebSocketProviders) return void 0;\n      const provider = chainWebSocketProviders[0]?.();\n      if (provider && activeChain.id === 42220) {\n        provider.formatter.formats.block = {\n          ...provider.formatter.formats.block,\n          difficulty: () => 0,\n          gasLimit: () => 0\n        };\n      }\n      return Object.assign(provider || {}, {\n        chains\n      });\n    }\n  };\n}\nfunction fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {\n  let {\n    stallTimeout\n  } = _ref4;\n  try {\n    return new providers.FallbackProvider(providers_.map((chainProvider, index) => {\n      const provider = chainProvider();\n      return {\n        provider,\n        priority: provider.priority ?? index,\n        stallTimeout: provider.stallTimeout ?? stallTimeout,\n        weight: provider.weight\n      };\n    }), targetQuorum);\n  } catch (error) {\n    if (error?.message?.includes(\"quorum will always fail; larger than total weight\")) {\n      if (targetQuorum === minQuorum) throw error;\n      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {\n        stallTimeout\n      });\n    }\n    throw error;\n  }\n}\n\n// src/client.ts\nimport { persist, subscribeWithSelector } from \"zustand/middleware\";\nimport { createStore } from \"zustand/vanilla\";\n\n// src/utils/assertActiveChain.ts\nfunction assertActiveChain(_ref5) {\n  let {\n    chainId,\n    signer\n  } = _ref5;\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain?.id;\n  if (activeChainId && chainId !== activeChainId) {\n    throw new ChainMismatchError({\n      activeChain: chains.find(x => x.id === activeChainId)?.name ?? `Chain ${activeChainId}`,\n      targetChain: chains.find(x => x.id === chainId)?.name ?? `Chain ${chainId}`\n    });\n  }\n  if (signer) {\n    const signerChainId = signer.provider?.network?.chainId;\n    if (signerChainId && chainId !== signerChainId) {\n      const connector = getClient().connector;\n      throw new ChainNotConfiguredError({\n        chainId,\n        connectorId: connector?.id ?? \"unknown\"\n      });\n    }\n  }\n}\n\n// src/utils/debounce.ts\nfunction debounce(fn) {\n  let waitTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let timeout;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (!waitTime) return fn(...args);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      timeout = null;\n      fn(...args);\n    }, waitTime);\n  };\n}\n\n// src/utils/deepEqual.ts\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    if (a.constructor !== b.constructor) return false;\n    let length;\n    let i;\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n      return true;\n    }\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\n// src/utils/deserialize.ts\nimport { BigNumber } from \"ethers\";\nvar findAndReplace = (cacheRef, _ref6) => {\n  let {\n    find,\n    replace\n  } = _ref6;\n  if (cacheRef && find(cacheRef)) {\n    return replace(cacheRef);\n  }\n  if (typeof cacheRef !== \"object\") {\n    return cacheRef;\n  }\n  if (Array.isArray(cacheRef)) {\n    return cacheRef.map(item => findAndReplace(item, {\n      find,\n      replace\n    }));\n  }\n  if (cacheRef instanceof Object) {\n    return Object.entries(cacheRef).reduce((curr, _ref7) => {\n      let [key, value] = _ref7;\n      return {\n        ...curr,\n        [key]: findAndReplace(value, {\n          find,\n          replace\n        })\n      };\n    }, {});\n  }\n  return cacheRef;\n};\nfunction deserialize(cachedString) {\n  const cache = JSON.parse(cachedString);\n  const deserializedCacheWithBigNumbers = findAndReplace(cache, {\n    find: data => data.type === \"BigNumber\",\n    replace: data => BigNumber.from(data.hex)\n  });\n  return deserializedCacheWithBigNumbers;\n}\n\n// src/utils/normalizeFunctionName.ts\nimport { BigNumber as BigNumber2 } from \"ethers\";\nimport { FunctionFragment, isAddress } from \"ethers/lib/utils.js\";\nfunction normalizeFunctionName(_ref8) {\n  let {\n    contract,\n    functionName,\n    args = []\n  } = _ref8;\n  if (functionName in contract.functions) return functionName;\n  const argsLength = args?.length ?? 0;\n  const overloadFunctions = Object.keys(contract.functions).filter(x => x.startsWith(`${functionName}(`)).map(x => ({\n    name: x,\n    fragment: FunctionFragment.fromString(x)\n  })).filter(x => argsLength === x.fragment.inputs.length);\n  for (const overloadFunction of overloadFunctions) {\n    const matched = args.every((arg, index) => {\n      const abiParameter = overloadFunction.fragment.inputs[index];\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) return overloadFunction.name;\n  }\n  return functionName;\n}\nfunction isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case \"address\":\n      return isAddress(arg);\n    case \"bool\":\n      return argType === \"boolean\";\n    case \"function\":\n      return argType === \"string\";\n    case \"string\":\n      return argType === \"string\";\n    default:\n      {\n        if (abiParameterType === \"tuple\" && \"components\" in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === \"number\" || argType === \"bigint\" || BigNumber2.isBigNumber(arg);\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === \"string\" || arg instanceof Uint8Array;\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, \"\")\n          }));\n        }\n        return false;\n      }\n  }\n}\n\n// src/utils/logger.ts\nfunction logWarn(message) {\n  getClient()?.config.logger?.warn?.(message);\n}\n\n// src/utils/minimizeContractInterface.ts\nimport { Contract } from \"ethers\";\nimport { FormatTypes } from \"ethers/lib/utils.js\";\nfunction minimizeContractInterface(config) {\n  try {\n    const minimizedAbi = config.abi.filter(x => x.type === \"function\" && x.name === config.functionName);\n    if (minimizedAbi.length === 0) throw new Error(\"Invalid ABI\");\n    return minimizedAbi;\n  } catch (error) {\n    const abi = Contract.getInterface(config.abi).format(FormatTypes.full);\n    const minimizedInterface = Array.isArray(abi) ? abi : [abi];\n    return minimizedInterface.filter(i => i.includes(config.functionName));\n  }\n}\n\n// src/utils/normalizeChainId.ts\nfunction normalizeChainId(chainId) {\n  if (typeof chainId === \"string\") return Number.parseInt(chainId, chainId.trim().substring(0, 2) === \"0x\" ? 16 : 10);\n  if (typeof chainId === \"bigint\") return Number(chainId);\n  return chainId;\n}\n\n// src/utils/parseContractResult.ts\nimport { Contract as Contract2 } from \"ethers\";\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\nfunction parseContractResult(_ref9) {\n  let {\n    abi,\n    data,\n    functionName\n  } = _ref9;\n  if (data && isPlainArray(data)) {\n    const iface = Contract2.getInterface(abi);\n    const fragment = iface.getFunction(functionName);\n    const isTuple = (fragment.outputs?.length || 0) > 1;\n    const data_ = isTuple ? data : [data];\n    const encodedResult = iface.encodeFunctionResult(functionName, data_);\n    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isTuple ? decodedResult : decodedResult[0];\n  }\n  return data;\n}\n\n// src/utils/serialize.ts\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join(\".\") || \".\";\n}\nfunction getCutoff(array, value) {\n  const {\n    length\n  } = array;\n  for (let index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n  return 0;\n}\nfunction createReplacer(replacer, circularReplacer) {\n  const hasReplacer = typeof replacer === \"function\";\n  const hasCircularReplacer = typeof circularReplacer === \"function\";\n  const cache = [];\n  const keys = [];\n  return function replace(key, value) {\n    if (typeof value === \"object\") {\n      if (cache.length) {\n        const thisCutoff = getCutoff(cache, this);\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n        keys[keys.length] = key;\n        const valueCutoff = getCutoff(cache, value);\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\nfunction serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent ?? void 0);\n}\n\n// src/storage.ts\nvar noopStorage = {\n  getItem: _key => \"\",\n  setItem: (_key, _value) => null,\n  removeItem: _key => null\n};\nfunction createStorage(_ref10) {\n  let {\n    deserialize: deserialize2 = deserialize,\n    key: prefix = \"wagmi\",\n    serialize: serialize2 = serialize,\n    storage\n  } = _ref10;\n  return {\n    ...storage,\n    getItem: function (key) {\n      let defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      const value = storage.getItem(`${prefix}.${key}`);\n      try {\n        return value ? deserialize2(value) : defaultState;\n      } catch (error) {\n        console.warn(error);\n        return defaultState;\n      }\n    },\n    setItem: (key, value) => {\n      if (value === null) {\n        storage.removeItem(`${prefix}.${key}`);\n      } else {\n        try {\n          storage.setItem(`${prefix}.${key}`, serialize2(value));\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    },\n    removeItem: key => storage.removeItem(`${prefix}.${key}`)\n  };\n}\n\n// src/client.ts\nvar storeKey = \"store\";\nvar _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;\nvar Client = class {\n  constructor(_ref11) {\n    let {\n      autoConnect = false,\n      connectors = [new InjectedConnector()],\n      provider,\n      storage = createStorage({\n        storage: typeof window !== \"undefined\" ? window.localStorage : noopStorage\n      }),\n      logger = {\n        warn: console.warn\n      },\n      webSocketProvider\n    } = _ref11;\n    __privateAdd(this, _addEffects);\n    this.providers = /* @__PURE__ */new Map();\n    this.webSocketProviders = /* @__PURE__ */new Map();\n    __privateAdd(this, _isAutoConnecting, void 0);\n    __privateAdd(this, _lastUsedConnector, void 0);\n    this.config = {\n      autoConnect,\n      connectors,\n      logger,\n      provider,\n      storage,\n      webSocketProvider\n    };\n    let status = \"disconnected\";\n    let chainId;\n    if (autoConnect) {\n      try {\n        const rawState = storage.getItem(storeKey);\n        const data = rawState?.state?.data;\n        status = data?.account ? \"reconnecting\" : \"connecting\";\n        chainId = data?.chain?.id;\n      } catch (_error) {}\n    }\n    this.store = createStore(subscribeWithSelector(persist(() => ({\n      connectors: typeof connectors === \"function\" ? connectors() : connectors,\n      provider: this.getProvider({\n        chainId\n      }),\n      status,\n      webSocketProvider: this.getWebSocketProvider({\n        chainId\n      })\n    }), {\n      name: storeKey,\n      storage,\n      partialize: state => ({\n        ...(autoConnect && {\n          data: {\n            account: state?.data?.account,\n            chain: state?.data?.chain\n          }\n        }),\n        chains: state?.chains\n      }),\n      version: 2\n    })));\n    this.storage = storage;\n    __privateSet(this, _lastUsedConnector, storage?.getItem(\"wallet\"));\n    __privateMethod(this, _addEffects, addEffects_fn).call(this);\n    if (autoConnect && typeof window !== \"undefined\") setTimeout(async () => await this.autoConnect(), 0);\n  }\n  get chains() {\n    return this.store.getState().chains;\n  }\n  get connectors() {\n    return this.store.getState().connectors;\n  }\n  get connector() {\n    return this.store.getState().connector;\n  }\n  get data() {\n    return this.store.getState().data;\n  }\n  get error() {\n    return this.store.getState().error;\n  }\n  get lastUsedChainId() {\n    return this.data?.chain?.id;\n  }\n  get provider() {\n    return this.store.getState().provider;\n  }\n  get status() {\n    return this.store.getState().status;\n  }\n  get subscribe() {\n    return this.store.subscribe;\n  }\n  get webSocketProvider() {\n    return this.store.getState().webSocketProvider;\n  }\n  setState(updater) {\n    const newState = typeof updater === \"function\" ? updater(this.store.getState()) : updater;\n    this.store.setState(newState, true);\n  }\n  clearState() {\n    this.setState(x => ({\n      ...x,\n      chains: void 0,\n      connector: void 0,\n      data: void 0,\n      error: void 0,\n      status: \"disconnected\"\n    }));\n  }\n  async destroy() {\n    if (this.connector) await this.connector.disconnect?.();\n    __privateSet(this, _isAutoConnecting, false);\n    this.clearState();\n    this.store.destroy();\n  }\n  async autoConnect() {\n    if (__privateGet(this, _isAutoConnecting)) return;\n    __privateSet(this, _isAutoConnecting, true);\n    this.setState(x => ({\n      ...x,\n      status: x.data?.account ? \"reconnecting\" : \"connecting\"\n    }));\n    const sorted = __privateGet(this, _lastUsedConnector) ? [...this.connectors].sort(x => x.id === __privateGet(this, _lastUsedConnector) ? -1 : 1) : this.connectors;\n    let connected = false;\n    for (const connector of sorted) {\n      if (!connector.ready || !connector.isAuthorized) continue;\n      const isAuthorized = await connector.isAuthorized();\n      if (!isAuthorized) continue;\n      const data = await connector.connect();\n      this.setState(x => ({\n        ...x,\n        connector,\n        chains: connector?.chains,\n        data,\n        status: \"connected\"\n      }));\n      connected = true;\n      break;\n    }\n    if (!connected) this.setState(x => ({\n      ...x,\n      data: void 0,\n      status: \"disconnected\"\n    }));\n    __privateSet(this, _isAutoConnecting, false);\n    return this.data;\n  }\n  getProvider() {\n    let {\n      bust,\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let provider_ = this.providers.get(chainId ?? -1);\n    if (provider_ && !bust) return provider_;\n    const {\n      provider\n    } = this.config;\n    provider_ = typeof provider === \"function\" ? provider({\n      chainId\n    }) : provider;\n    this.providers.set(chainId ?? -1, provider_);\n    return provider_;\n  }\n  getWebSocketProvider() {\n    let {\n      bust,\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let webSocketProvider_ = this.webSocketProviders.get(chainId ?? -1);\n    if (webSocketProvider_ && !bust) return webSocketProvider_;\n    const {\n      webSocketProvider\n    } = this.config;\n    webSocketProvider_ = typeof webSocketProvider === \"function\" ? webSocketProvider({\n      chainId\n    }) : webSocketProvider;\n    if (webSocketProvider_) this.webSocketProviders.set(chainId ?? -1, webSocketProvider_);\n    return webSocketProvider_;\n  }\n  setLastUsedConnector() {\n    let lastUsedConnector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.storage?.setItem(\"wallet\", lastUsedConnector);\n  }\n};\n_isAutoConnecting = new WeakMap();\n_lastUsedConnector = new WeakMap();\n_addEffects = new WeakSet();\naddEffects_fn = function () {\n  const onChange = data => {\n    this.setState(x => ({\n      ...x,\n      data: {\n        ...x.data,\n        ...data\n      }\n    }));\n  };\n  const onDisconnect = () => {\n    this.clearState();\n  };\n  const onError = error => {\n    this.setState(x => ({\n      ...x,\n      error\n    }));\n  };\n  this.store.subscribe(_ref12 => {\n    let {\n      connector\n    } = _ref12;\n    return connector;\n  }, (connector, prevConnector) => {\n    prevConnector?.off?.(\"change\", onChange);\n    prevConnector?.off?.(\"disconnect\", onDisconnect);\n    prevConnector?.off?.(\"error\", onError);\n    if (!connector) return;\n    connector.on?.(\"change\", onChange);\n    connector.on?.(\"disconnect\", onDisconnect);\n    connector.on?.(\"error\", onError);\n  });\n  const {\n    provider,\n    webSocketProvider\n  } = this.config;\n  const subscribeProvider = typeof provider === \"function\";\n  const subscribeWebSocketProvider = typeof webSocketProvider === \"function\";\n  if (subscribeProvider || subscribeWebSocketProvider) this.store.subscribe(_ref13 => {\n    let {\n      data\n    } = _ref13;\n    return data?.chain?.id;\n  }, chainId => {\n    this.setState(x => ({\n      ...x,\n      provider: this.getProvider({\n        bust: true,\n        chainId\n      }),\n      webSocketProvider: this.getWebSocketProvider({\n        bust: true,\n        chainId\n      })\n    }));\n  });\n};\nvar client;\nfunction createClient(config) {\n  const client_ = new Client(config);\n  client = client_;\n  return client_;\n}\nfunction getClient() {\n  if (!client) {\n    throw new Error(\"No wagmi client found. Ensure you have set up a client: https://wagmi.sh/react/client\");\n  }\n  return client;\n}\n\n// src/actions/accounts/connect.ts\nasync function connect(_ref14) {\n  let {\n    chainId,\n    connector\n  } = _ref14;\n  const client2 = getClient();\n  const activeConnector = client2.connector;\n  if (activeConnector && connector.id === activeConnector.id) throw new ConnectorAlreadyConnectedError();\n  try {\n    client2.setState(x => ({\n      ...x,\n      status: \"connecting\"\n    }));\n    const data = await connector.connect({\n      chainId\n    });\n    client2.setLastUsedConnector(connector.id);\n    client2.setState(x => ({\n      ...x,\n      connector,\n      chains: connector?.chains,\n      data,\n      status: \"connected\"\n    }));\n    client2.storage.setItem(\"connected\", true);\n    return {\n      ...data,\n      connector\n    };\n  } catch (err) {\n    client2.setState(x => {\n      return {\n        ...x,\n        status: x.connector ? \"connected\" : \"disconnected\"\n      };\n    });\n    throw err;\n  }\n}\n\n// src/actions/accounts/disconnect.ts\nasync function disconnect() {\n  const client2 = getClient();\n  if (client2.connector) await client2.connector.disconnect();\n  client2.clearState();\n  client2.storage.removeItem(\"connected\");\n}\n\n// src/actions/accounts/fetchBalance.ts\nimport { formatUnits as formatUnits3, parseBytes32String as parseBytes32String2 } from \"ethers/lib/utils.js\";\n\n// src/constants/abis.ts\nvar erc20ABI = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"allowance\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"decimals\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transfer\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}];\nvar erc20ABI_bytes32 = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"allowance\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"decimals\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint8\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"bytes32\"\n  }]\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"bytes32\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transfer\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}];\nvar erc721ABI = [{\n  type: \"event\",\n  name: \"Approval\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"event\",\n  name: \"ApprovalForAll\",\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"operator\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"approved\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"event\",\n  name: \"Transfer\",\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"approve\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"balanceOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"getApproved\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"address\"\n  }]\n}, {\n  type: \"function\",\n  name: \"isApprovedForAll\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"operator\",\n    type: \"address\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }]\n}, {\n  type: \"function\",\n  name: \"name\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"ownerOf\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }]\n}, {\n  type: \"function\",\n  name: \"safeTransferFrom\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"safeTransferFrom\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"id\",\n    type: \"uint256\"\n  }, {\n    name: \"data\",\n    type: \"bytes\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"setApprovalForAll\",\n  stateMutability: \"nonpayable\",\n  inputs: [{\n    name: \"operator\",\n    type: \"address\"\n  }, {\n    name: \"approved\",\n    type: \"bool\"\n  }],\n  outputs: []\n}, {\n  type: \"function\",\n  name: \"symbol\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenByIndex\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"index\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenByIndex\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"index\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"tokenURI\",\n  stateMutability: \"view\",\n  inputs: [{\n    name: \"tokenId\",\n    type: \"uint256\"\n  }],\n  outputs: [{\n    name: \"\",\n    type: \"string\"\n  }]\n}, {\n  type: \"function\",\n  name: \"totalSupply\",\n  stateMutability: \"view\",\n  inputs: [],\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }]\n}, {\n  type: \"function\",\n  name: \"transferFrom\",\n  stateMutability: \"payable\",\n  inputs: [{\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    name: \"recipient\",\n    type: \"address\"\n  }, {\n    name: \"tokeId\",\n    type: \"uint256\"\n  }],\n  outputs: []\n}];\nvar multicallABI = [{\n  inputs: [{\n    components: [{\n      name: \"target\",\n      type: \"address\"\n    }, {\n      name: \"allowFailure\",\n      type: \"bool\"\n    }, {\n      name: \"callData\",\n      type: \"bytes\"\n    }],\n    name: \"calls\",\n    type: \"tuple[]\"\n  }],\n  name: \"aggregate3\",\n  outputs: [{\n    components: [{\n      name: \"success\",\n      type: \"bool\"\n    }, {\n      name: \"returnData\",\n      type: \"bytes\"\n    }],\n    name: \"returnData\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar erc4626ABI = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Approval\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"Deposit\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"from\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"to\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"value\",\n    type: \"uint256\"\n  }],\n  name: \"Transfer\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    name: \"sender\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    indexed: false,\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"Withdraw\",\n  type: \"event\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }, {\n    name: \"spender\",\n    type: \"address\"\n  }],\n  name: \"allowance\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"spender\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"approve\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"asset\",\n  outputs: [{\n    name: \"assetTokenAddress\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"account\",\n    type: \"address\"\n  }],\n  name: \"balanceOf\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"convertToAssets\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"convertToShares\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }],\n  name: \"deposit\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"caller\",\n    type: \"address\"\n  }],\n  name: \"maxDeposit\",\n  outputs: [{\n    name: \"maxAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"caller\",\n    type: \"address\"\n  }],\n  name: \"maxMint\",\n  outputs: [{\n    name: \"maxShares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"maxRedeem\",\n  outputs: [{\n    name: \"maxShares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"maxWithdraw\",\n  outputs: [{\n    name: \"maxAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }],\n  name: \"mint\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"previewDeposit\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"previewMint\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  name: \"previewRedeem\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  name: \"previewWithdraw\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"redeem\",\n  outputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"totalAssets\",\n  outputs: [{\n    name: \"totalManagedAssets\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"totalSupply\",\n  outputs: [{\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"transfer\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"from\",\n    type: \"address\"\n  }, {\n    name: \"to\",\n    type: \"address\"\n  }, {\n    name: \"amount\",\n    type: \"uint256\"\n  }],\n  name: \"transferFrom\",\n  outputs: [{\n    name: \"\",\n    type: \"bool\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    name: \"assets\",\n    type: \"uint256\"\n  }, {\n    name: \"receiver\",\n    type: \"address\"\n  }, {\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"withdraw\",\n  outputs: [{\n    name: \"shares\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}];\n\n// src/constants/units.ts\nvar units = [\"wei\", \"kwei\", \"mwei\", \"gwei\", \"szabo\", \"finney\", \"ether\"];\n\n// src/actions/contracts/fetchToken.ts\nimport { formatUnits, parseBytes32String } from \"ethers/lib/utils.js\";\nasync function fetchToken(_ref15) {\n  let {\n    address,\n    chainId,\n    formatUnits: units2 = \"ether\"\n  } = _ref15;\n  async function fetchToken_(_ref16) {\n    let {\n      abi\n    } = _ref16;\n    const erc20Config = {\n      address,\n      abi,\n      chainId\n    };\n    const [decimals, name, symbol, totalSupply] = await readContracts({\n      allowFailure: false,\n      contracts: [{\n        ...erc20Config,\n        functionName: \"decimals\"\n      }, {\n        ...erc20Config,\n        functionName: \"name\"\n      }, {\n        ...erc20Config,\n        functionName: \"symbol\"\n      }, {\n        ...erc20Config,\n        functionName: \"totalSupply\"\n      }]\n    });\n    return {\n      address,\n      decimals,\n      name,\n      symbol,\n      totalSupply: {\n        formatted: formatUnits(totalSupply, units2),\n        value: totalSupply\n      }\n    };\n  }\n  try {\n    return await fetchToken_({\n      abi: erc20ABI\n    });\n  } catch (err) {\n    if (err instanceof ContractResultDecodeError) {\n      const {\n        name,\n        symbol,\n        ...rest\n      } = await fetchToken_({\n        abi: erc20ABI_bytes32\n      });\n      return {\n        name: parseBytes32String(name),\n        symbol: parseBytes32String(symbol),\n        ...rest\n      };\n    }\n    throw err;\n  }\n}\n\n// src/actions/contracts/getContract.ts\nimport { Contract as EthersContract } from \"ethers\";\nfunction getContract(_ref17) {\n  let {\n    address,\n    abi,\n    signerOrProvider\n  } = _ref17;\n  return new EthersContract(address, abi, signerOrProvider);\n}\n\n// src/actions/contracts/prepareWriteContract.ts\nasync function prepareWriteContract(_ref18) {\n  let {\n    abi,\n    address,\n    chainId,\n    functionName,\n    overrides,\n    signer: signer_,\n    ...config\n  } = _ref18;\n  const signer = signer_ ?? (await fetchSigner({\n    chainId\n  }));\n  if (!signer) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId,\n    signer\n  });\n  const contract = getContract({\n    address,\n    abi,\n    signerOrProvider: signer\n  });\n  const args = config.args;\n  const normalizedFunctionName = normalizeFunctionName({\n    contract,\n    functionName,\n    args\n  });\n  const populateTransactionFn = contract.populateTransaction[normalizedFunctionName];\n  if (!populateTransactionFn) throw new ContractMethodDoesNotExistError({\n    address,\n    functionName: normalizedFunctionName\n  });\n  const params = [...(args ?? []), ...(overrides ? [overrides] : [])];\n  const unsignedTransaction = await populateTransactionFn(...params);\n  const gasLimit = unsignedTransaction.gasLimit || (await signer.estimateGas(unsignedTransaction));\n  const minimizedAbi = minimizeContractInterface({\n    abi,\n    functionName\n  });\n  return {\n    abi: minimizedAbi,\n    address,\n    chainId,\n    functionName,\n    mode: \"prepared\",\n    request: {\n      ...unsignedTransaction,\n      gasLimit\n    }\n  };\n}\n\n// src/actions/providers/getProvider.ts\nfunction getProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client2 = getClient();\n  if (chainId) return client2.getProvider({\n    chainId\n  }) || client2.provider;\n  return client2.provider;\n}\n\n// src/actions/providers/getWebSocketProvider.ts\nfunction getWebSocketProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client2 = getClient();\n  if (chainId) return client2.getWebSocketProvider({\n    chainId\n  }) || client2.webSocketProvider;\n  return client2.webSocketProvider;\n}\n\n// src/actions/providers/watchProvider.ts\nfunction watchProvider(args, callback) {\n  const client2 = getClient();\n  const handleChange = async () => callback(getProvider(args));\n  const unsubscribe = client2.subscribe(_ref19 => {\n    let {\n      provider\n    } = _ref19;\n    return provider;\n  }, handleChange);\n  return unsubscribe;\n}\n\n// src/actions/providers/watchWebSocketProvider.ts\nfunction watchWebSocketProvider(args, callback) {\n  const client2 = getClient();\n  const handleChange = async () => callback(getWebSocketProvider(args));\n  const unsubscribe = client2.subscribe(_ref20 => {\n    let {\n      webSocketProvider\n    } = _ref20;\n    return webSocketProvider;\n  }, handleChange);\n  return unsubscribe;\n}\n\n// src/actions/contracts/multicall.ts\nasync function multicall(_ref21) {\n  let {\n    allowFailure = true,\n    chainId,\n    contracts,\n    overrides\n  } = _ref21;\n  const provider = getProvider({\n    chainId\n  });\n  if (!provider.chains) throw new ProviderChainsNotFound();\n  const chain = provider.chains.find(chain2 => chain2.id === chainId) || provider.chains[0];\n  if (!chain) throw new ProviderChainsNotFound();\n  if (!chain?.contracts?.multicall3) throw new ChainDoesNotSupportMulticallError({\n    chain\n  });\n  if (typeof overrides?.blockTag === \"number\" && overrides?.blockTag < (chain.contracts.multicall3.blockCreated ?? 0)) throw new ChainDoesNotSupportMulticallError({\n    blockNumber: overrides?.blockTag,\n    chain\n  });\n  const multicallContract = getContract({\n    address: chain.contracts.multicall3.address,\n    abi: multicallABI,\n    signerOrProvider: provider\n  });\n  const calls = contracts.map(_ref22 => {\n    let {\n      address,\n      abi,\n      functionName,\n      ...config\n    } = _ref22;\n    const {\n      args\n    } = config || {};\n    const contract = getContract({\n      address,\n      abi\n    });\n    const params2 = args ?? [];\n    const normalizedFunctionName = normalizeFunctionName({\n      contract,\n      functionName,\n      args\n    });\n    try {\n      const contractFunction = contract[normalizedFunctionName];\n      if (!contractFunction) logWarn(`\"${normalizedFunctionName}\" is not in the interface for contract \"${address}\"`);\n      const callData = contract.interface.encodeFunctionData(normalizedFunctionName, params2);\n      return {\n        target: address,\n        allowFailure,\n        callData\n      };\n    } catch (err) {\n      if (!allowFailure) throw err;\n      return {\n        target: address,\n        allowFailure,\n        callData: \"0x\"\n      };\n    }\n  });\n  const params = [...[calls], ...(overrides ? [overrides] : [])];\n  const results = await multicallContract.aggregate3(...params);\n  return results.map((_ref23, i) => {\n    let {\n      returnData,\n      success\n    } = _ref23;\n    const {\n      address,\n      abi,\n      functionName,\n      ...rest\n    } = contracts[i];\n    const contract = getContract({\n      address,\n      abi\n    });\n    const args = rest.args;\n    const normalizedFunctionName = normalizeFunctionName({\n      contract,\n      functionName,\n      args\n    });\n    if (!success) {\n      let error;\n      try {\n        contract.interface.decodeFunctionResult(normalizedFunctionName, returnData);\n      } catch (err) {\n        error = new ContractMethodRevertedError({\n          address,\n          args,\n          chainId: chain.id,\n          functionName: normalizedFunctionName,\n          errorMessage: err.message\n        });\n        if (!allowFailure) throw error;\n        logWarn(error.message);\n      }\n      return null;\n    }\n    if (returnData === \"0x\") {\n      const error = new ContractMethodNoResultError({\n        address,\n        args,\n        chainId: chain.id,\n        functionName: normalizedFunctionName\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n    try {\n      const result = contract.interface.decodeFunctionResult(normalizedFunctionName, returnData);\n      return Array.isArray(result) && result.length === 1 ? result[0] : result;\n    } catch (err) {\n      const error = new ContractResultDecodeError({\n        address,\n        args,\n        chainId: chain.id,\n        functionName: normalizedFunctionName,\n        errorMessage: err.message\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n  });\n}\n\n// src/actions/contracts/readContract.ts\nasync function readContract(_ref24) {\n  let {\n    address,\n    chainId,\n    abi,\n    functionName,\n    overrides,\n    ...config\n  } = _ref24;\n  const provider = getProvider({\n    chainId\n  });\n  const contract = getContract({\n    address,\n    abi,\n    signerOrProvider: provider\n  });\n  const args = config.args;\n  const normalizedFunctionName = normalizeFunctionName({\n    contract,\n    functionName,\n    args\n  });\n  const contractFunction = contract[normalizedFunctionName];\n  if (!contractFunction) throw new ContractMethodDoesNotExistError({\n    address,\n    functionName: normalizedFunctionName\n  });\n  const params = [...(args ?? []), ...(overrides ? [overrides] : [])];\n  return contractFunction?.(...params);\n}\n\n// src/actions/contracts/readContracts.ts\nasync function readContracts(_ref25) {\n  let {\n    allowFailure = true,\n    contracts,\n    overrides\n  } = _ref25;\n  try {\n    const provider = getProvider();\n    const contractsByChainId = contracts.reduce((contracts2, contract, index) => {\n      const chainId = contract.chainId ?? provider.network.chainId;\n      return {\n        ...contracts2,\n        [chainId]: [...(contracts2[chainId] || []), {\n          contract,\n          index\n        }]\n      };\n    }, {});\n    const promises = () => Object.entries(contractsByChainId).map(_ref26 => {\n      let [chainId, contracts2] = _ref26;\n      return multicall({\n        allowFailure,\n        chainId: parseInt(chainId),\n        contracts: contracts2.map(_ref27 => {\n          let {\n            contract\n          } = _ref27;\n          return contract;\n        }),\n        overrides\n      });\n    });\n    let multicallResults;\n    if (allowFailure) {\n      multicallResults = (await Promise.allSettled(promises())).map(result => {\n        if (result.status === \"fulfilled\") return result.value;\n        if (result.reason instanceof ChainDoesNotSupportMulticallError) {\n          logWarn(result.reason.message);\n          throw result.reason;\n        }\n        return null;\n      }).flat();\n    } else {\n      multicallResults = (await Promise.all(promises())).flat();\n    }\n    const resultIndexes = Object.values(contractsByChainId).map(contracts2 => contracts2.map(_ref28 => {\n      let {\n        index\n      } = _ref28;\n      return index;\n    })).flat();\n    return multicallResults.reduce((results, result, index) => {\n      if (results) results[resultIndexes[index]] = result;\n      return results;\n    }, []);\n  } catch (err) {\n    if (err instanceof ContractResultDecodeError) throw err;\n    if (err instanceof ContractMethodNoResultError) throw err;\n    if (err instanceof ContractMethodRevertedError) throw err;\n    const promises = () => contracts.map(contract => readContract({\n      ...contract,\n      overrides\n    }));\n    if (allowFailure) return (await Promise.allSettled(promises())).map((result, i) => {\n      if (result.status === \"fulfilled\") return result.value;\n      const {\n        address,\n        args,\n        chainId,\n        functionName\n      } = contracts[i];\n      const error = new ContractMethodRevertedError({\n        address,\n        functionName,\n        chainId: chainId ?? 1,\n        args,\n        errorMessage: result.reason\n      });\n      logWarn(error.message);\n      return null;\n    });\n    return await Promise.all(promises());\n  }\n}\n\n// src/actions/contracts/watchContractEvent.ts\nimport { shallow } from \"zustand/shallow\";\nfunction watchContractEvent(_ref29, callback) {\n  let {\n    address,\n    abi,\n    chainId,\n    eventName,\n    once\n  } = _ref29;\n  const handler = function () {\n    return callback(...arguments);\n  };\n  let contract;\n  const watchEvent = async () => {\n    if (contract) contract?.off(eventName, handler);\n    const signerOrProvider = getWebSocketProvider({\n      chainId\n    }) || getProvider({\n      chainId\n    });\n    contract = getContract({\n      address,\n      abi,\n      signerOrProvider\n    });\n    if (once) contract.once(eventName, handler);else contract.on(eventName, handler);\n  };\n  watchEvent();\n  const client2 = getClient();\n  const unsubscribe = client2.subscribe(_ref30 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref30;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, watchEvent, {\n    equalityFn: shallow\n  });\n  return () => {\n    contract?.off(eventName, handler);\n    unsubscribe();\n  };\n}\n\n// src/actions/network-status/watchBlockNumber.ts\nimport { shallow as shallow2 } from \"zustand/shallow\";\n\n// src/actions/network-status/fetchBlockNumber.ts\nasync function fetchBlockNumber() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const blockNumber = await provider.getBlockNumber();\n  return blockNumber;\n}\n\n// src/actions/network-status/watchBlockNumber.ts\nfunction watchBlockNumber(args, callback) {\n  const debouncedCallback = debounce(callback, 1);\n  let previousProvider;\n  const createListener = provider => {\n    if (previousProvider) {\n      previousProvider?.off(\"block\", debouncedCallback);\n    }\n    provider.on(\"block\", debouncedCallback);\n    previousProvider = provider;\n  };\n  const provider_ = getWebSocketProvider({\n    chainId: args.chainId\n  }) ?? getProvider({\n    chainId: args.chainId\n  });\n  if (args.listen) createListener(provider_);\n  let active = true;\n  const client2 = getClient();\n  const unsubscribe = client2.subscribe(_ref31 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref31;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, async _ref32 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref32;\n    const provider_2 = webSocketProvider ?? provider;\n    if (args.listen && !args.chainId && provider_2) {\n      createListener(provider_2);\n    }\n    const blockNumber = await fetchBlockNumber({\n      chainId: args.chainId\n    });\n    if (!active) return;\n    callback(blockNumber);\n  }, {\n    equalityFn: shallow2\n  });\n  return () => {\n    active = false;\n    unsubscribe();\n    provider_?.off(\"block\", debouncedCallback);\n    previousProvider?.off(\"block\", debouncedCallback);\n  };\n}\n\n// src/actions/contracts/watchMulticall.ts\nfunction watchMulticall(config, callback) {\n  const client2 = getClient();\n  const handleChange = async () => callback(await multicall(config));\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = client2.subscribe(_ref33 => {\n    let {\n      provider\n    } = _ref33;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/watchReadContract.ts\nfunction watchReadContract(config, callback) {\n  const client2 = getClient();\n  const handleChange = async () => callback(await readContract(config));\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = client2.subscribe(_ref34 => {\n    let {\n      provider\n    } = _ref34;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/contracts/watchReadContracts.ts\nfunction watchReadContracts(config, callback) {\n  const client2 = getClient();\n  const handleChange = async () => callback(await readContracts(config));\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : void 0;\n  const unsubscribe = client2.subscribe(_ref35 => {\n    let {\n      provider\n    } = _ref35;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch?.();\n  };\n}\n\n// src/actions/transactions/fetchTransaction.ts\nasync function fetchTransaction(_ref36) {\n  let {\n    chainId,\n    hash\n  } = _ref36;\n  const provider = getProvider({\n    chainId\n  });\n  return provider.getTransaction(hash);\n}\n\n// src/actions/transactions/prepareSendTransaction.ts\nimport { isAddress as isAddress2 } from \"ethers/lib/utils.js\";\n\n// src/actions/ens/fetchEnsAddress.ts\nimport { getAddress } from \"ethers/lib/utils.js\";\nasync function fetchEnsAddress(_ref37) {\n  let {\n    chainId,\n    name\n  } = _ref37;\n  const provider = getProvider({\n    chainId\n  });\n  const address = await provider.resolveName(name);\n  try {\n    return address ? getAddress(address) : null;\n  } catch (_error) {\n    return null;\n  }\n}\n\n// src/actions/ens/fetchEnsAvatar.ts\nasync function fetchEnsAvatar(_ref38) {\n  let {\n    address,\n    chainId\n  } = _ref38;\n  const provider = getProvider({\n    chainId\n  });\n  const avatar = await provider.getAvatar(address);\n  return avatar;\n}\n\n// src/actions/ens/fetchEnsName.ts\nimport { getAddress as getAddress2 } from \"ethers/lib/utils.js\";\nasync function fetchEnsName(_ref39) {\n  let {\n    address,\n    chainId\n  } = _ref39;\n  const provider = getProvider({\n    chainId\n  });\n  return provider.lookupAddress(getAddress2(address));\n}\n\n// src/actions/ens/fetchEnsResolver.ts\nasync function fetchEnsResolver(_ref40) {\n  let {\n    chainId,\n    name\n  } = _ref40;\n  const provider = getProvider({\n    chainId\n  });\n  const resolver = await provider.getResolver(name);\n  return resolver;\n}\n\n// src/actions/transactions/prepareSendTransaction.ts\nasync function prepareSendTransaction(_ref41) {\n  let {\n    chainId,\n    request,\n    signer: signer_\n  } = _ref41;\n  const signer = signer_ ?? (await fetchSigner({\n    chainId\n  }));\n  if (!signer) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId,\n    signer\n  });\n  const [to, gasLimit] = await Promise.all([isAddress2(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({\n    name: request.to\n  }), request.gasLimit ? Promise.resolve(request.gasLimit) : signer.estimateGas(request)]);\n  if (!to) throw new Error(\"Could not resolve ENS name\");\n  return {\n    ...(chainId ? {\n      chainId\n    } : {}),\n    request: {\n      ...request,\n      gasLimit,\n      to\n    },\n    mode: \"prepared\"\n  };\n}\n\n// src/actions/transactions/sendTransaction.ts\nasync function sendTransaction(_ref42) {\n  let {\n    chainId,\n    mode,\n    request\n  } = _ref42;\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  if (mode === \"prepared\") {\n    if (!request.gasLimit) throw new Error(\"`gasLimit` is required\");\n    if (!request.to) throw new Error(\"`to` is required\");\n  }\n  if (chainId) assertActiveChain({\n    chainId,\n    signer\n  });\n  try {\n    const uncheckedSigner = signer.connectUnchecked?.();\n    const {\n      hash,\n      wait\n    } = await (uncheckedSigner ?? signer).sendTransaction(request);\n    return {\n      hash,\n      wait\n    };\n  } catch (error) {\n    if (error.code === 4001 || error.code === \"ACTION_REJECTED\") throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\n// src/actions/transactions/waitForTransaction.ts\nimport { toUtf8String } from \"ethers/lib/utils.js\";\n\n// src/actions/network-status/fetchFeeData.ts\nimport { formatUnits as formatUnits2 } from \"ethers/lib/utils.js\";\nasync function fetchFeeData() {\n  let {\n    chainId,\n    formatUnits: units2 = \"wei\"\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const feeData = await provider.getFeeData();\n  const formatted = {\n    gasPrice: feeData.gasPrice ? formatUnits2(feeData.gasPrice, units2) : null,\n    maxFeePerGas: feeData.maxFeePerGas ? formatUnits2(feeData.maxFeePerGas, units2) : null,\n    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? formatUnits2(feeData.maxPriorityFeePerGas, units2) : null\n  };\n  return {\n    ...feeData,\n    formatted\n  };\n}\n\n// src/actions/transactions/waitForTransaction.ts\nasync function waitForTransaction(_ref43) {\n  let {\n    chainId,\n    confirmations = 1,\n    hash,\n    onSpeedUp,\n    timeout = 0\n  } = _ref43;\n  const provider = getProvider({\n    chainId\n  });\n  const [blockNumber, transaction] = await Promise.all([fetchBlockNumber(), fetchTransaction({\n    hash\n  })]);\n  let replaceable = null;\n  if (confirmations !== 0 && transaction?.to) {\n    replaceable = {\n      data: transaction.data,\n      from: transaction.from,\n      nonce: transaction.nonce,\n      startBlock: blockNumber,\n      to: transaction.to,\n      value: transaction.value\n    };\n  }\n  try {\n    const receipt = await provider._waitForTransaction(hash, confirmations, timeout, replaceable);\n    if (receipt.status === 0) {\n      const code = await provider.call(receipt, receipt.blockNumber);\n      const reason = toUtf8String(`0x${code.substring(138)}`);\n      throw new Error(reason);\n    }\n    return receipt;\n  } catch (err) {\n    if (err?.reason === \"repriced\") {\n      onSpeedUp?.(err.replacement);\n      return waitForTransaction({\n        hash: err.replacement?.hash,\n        confirmations,\n        timeout\n      });\n    }\n    throw err;\n  }\n}\n\n// src/actions/transactions/watchPendingTransactions.ts\nimport { shallow as shallow3 } from \"zustand/shallow\";\nfunction watchPendingTransactions(args, callback) {\n  let previousProvider;\n  const createListener = provider => {\n    if (previousProvider) {\n      previousProvider?.off(\"pending\", callback);\n    }\n    provider.on(\"pending\", callback);\n    previousProvider = provider;\n  };\n  const provider_ = getWebSocketProvider({\n    chainId: args.chainId\n  }) ?? getProvider({\n    chainId: args.chainId\n  });\n  createListener(provider_);\n  const client2 = getClient();\n  const unsubscribe = client2.subscribe(_ref44 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref44;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, async _ref45 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref45;\n    const provider_2 = webSocketProvider ?? provider;\n    if (!args.chainId && provider_2) {\n      createListener(provider_2);\n    }\n  }, {\n    equalityFn: shallow3\n  });\n  return () => {\n    unsubscribe();\n    provider_?.off(\"pending\", callback);\n    previousProvider?.off(\"pending\", callback);\n  };\n}\n\n// src/actions/contracts/writeContract.ts\nasync function writeContract(_ref46) {\n  let {\n    address,\n    args,\n    chainId,\n    abi,\n    functionName,\n    mode,\n    overrides,\n    request: request_\n  } = _ref46;\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  if (chainId) assertActiveChain({\n    chainId,\n    signer\n  });\n  if (mode === \"prepared\") {\n    if (!request_) throw new Error(\"`request` is required\");\n  }\n  const request = mode === \"recklesslyUnprepared\" ? (await prepareWriteContract({\n    address,\n    args,\n    chainId,\n    abi,\n    functionName,\n    overrides\n  })).request : request_;\n  const transaction = await sendTransaction({\n    request,\n    mode: \"prepared\"\n  });\n  return transaction;\n}\n\n// src/actions/accounts/fetchBalance.ts\nasync function fetchBalance(_ref47) {\n  let {\n    address,\n    chainId,\n    formatUnits: unit,\n    token\n  } = _ref47;\n  const client2 = getClient();\n  const provider = getProvider({\n    chainId\n  });\n  if (token) {\n    const fetchContractBalance = async _ref48 => {\n      let {\n        abi\n      } = _ref48;\n      const erc20Config = {\n        abi,\n        address: token,\n        chainId\n      };\n      const [value2, decimals, symbol] = await readContracts({\n        allowFailure: false,\n        contracts: [{\n          ...erc20Config,\n          functionName: \"balanceOf\",\n          args: [address]\n        }, {\n          ...erc20Config,\n          functionName: \"decimals\"\n        }, {\n          ...erc20Config,\n          functionName: \"symbol\"\n        }]\n      });\n      return {\n        decimals,\n        formatted: formatUnits3(value2 ?? \"0\", unit ?? decimals),\n        symbol,\n        value: value2\n      };\n    };\n    try {\n      return await fetchContractBalance({\n        abi: erc20ABI\n      });\n    } catch (err) {\n      if (err instanceof ContractResultDecodeError) {\n        const {\n          symbol,\n          ...rest\n        } = await fetchContractBalance({\n          abi: erc20ABI_bytes32\n        });\n        return {\n          symbol: parseBytes32String2(symbol),\n          ...rest\n        };\n      }\n      throw err;\n    }\n  }\n  const chains = [...(client2.provider.chains || []), ...(client2.chains ?? [])];\n  const value = await provider.getBalance(address);\n  const chain = chains.find(x => x.id === provider.network.chainId);\n  return {\n    decimals: chain?.nativeCurrency.decimals ?? 18,\n    formatted: formatUnits3(value ?? \"0\", unit ?? \"ether\"),\n    symbol: chain?.nativeCurrency.symbol ?? \"ETH\",\n    value\n  };\n}\n\n// src/actions/accounts/fetchSigner.ts\nasync function fetchSigner() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client2 = getClient();\n  const signer = (await client2.connector?.getSigner?.({\n    chainId\n  })) || null;\n  return signer;\n}\n\n// src/actions/accounts/getAccount.ts\nfunction getAccount() {\n  const {\n    data,\n    connector,\n    status\n  } = getClient();\n  switch (status) {\n    case \"connected\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n    case \"reconnecting\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: !!data?.account,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: true,\n        status\n      };\n    case \"connecting\":\n      return {\n        address: data?.account,\n        connector,\n        isConnected: false,\n        isConnecting: true,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n    case \"disconnected\":\n      return {\n        address: void 0,\n        connector: void 0,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n        status\n      };\n  }\n}\n\n// src/actions/accounts/getNetwork.ts\nfunction getNetwork() {\n  const client2 = getClient();\n  const chainId = client2.data?.chain?.id;\n  const activeChains = client2.chains ?? [];\n  const activeChain = [...(client2.provider.chains || []), ...activeChains].find(x => x.id === chainId) ?? {\n    id: chainId,\n    name: `Chain ${chainId}`,\n    network: `${chainId}`,\n    nativeCurrency: {\n      name: \"Ether\",\n      decimals: 18,\n      symbol: \"ETH\"\n    },\n    rpcUrls: {\n      default: {\n        http: [\"\"]\n      },\n      public: {\n        http: [\"\"]\n      }\n    }\n  };\n  return {\n    chain: chainId ? {\n      ...activeChain,\n      ...client2.data?.chain,\n      id: chainId\n    } : void 0,\n    chains: activeChains\n  };\n}\n\n// src/actions/accounts/signMessage.ts\nasync function signMessage(args) {\n  try {\n    const signer = await fetchSigner();\n    if (!signer) throw new ConnectorNotFoundError();\n    return await signer.signMessage(args.message);\n  } catch (error) {\n    if (error.code === 4001 || error.code === \"ACTION_REJECTED\") throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\n// src/actions/accounts/signTypedData.ts\nasync function signTypedData(_ref49) {\n  let {\n    domain,\n    types,\n    value\n  } = _ref49;\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const {\n    chainId: chainId_\n  } = domain;\n  const chainId = chainId_ ? normalizeChainId(chainId_) : void 0;\n  if (chainId) assertActiveChain({\n    chainId,\n    signer\n  });\n  const types_ = Object.entries(types).filter(_ref50 => {\n    let [key] = _ref50;\n    return key !== \"EIP712Domain\";\n  }).reduce((types2, _ref51) => {\n    let [key, attributes] = _ref51;\n    types2[key] = attributes.filter(attr => attr.type !== \"EIP712Domain\");\n    return types2;\n  }, {});\n  try {\n    return await signer._signTypedData(domain, types_, value);\n  } catch (error) {\n    if (error.code === 4001 || error.code === \"ACTION_REJECTED\") throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\n// src/actions/accounts/switchNetwork.ts\nasync function switchNetwork(_ref52) {\n  let {\n    chainId\n  } = _ref52;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n  if (!connector.switchChain) throw new SwitchChainNotSupportedError({\n    connector\n  });\n  return connector.switchChain(chainId);\n}\n\n// src/actions/accounts/watchAccount.ts\nimport { shallow as shallow4 } from \"zustand/shallow\";\nfunction watchAccount(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client2 = getClient();\n  const handleChange = () => callback(getAccount());\n  const unsubscribe = client2.subscribe(_ref53 => {\n    let {\n      data,\n      connector,\n      status\n    } = _ref53;\n    return selector({\n      address: data?.account,\n      connector,\n      status\n    });\n  }, handleChange, {\n    equalityFn: shallow4\n  });\n  return unsubscribe;\n}\n\n// src/actions/accounts/watchNetwork.ts\nimport { shallow as shallow5 } from \"zustand/shallow\";\nfunction watchNetwork(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client2 = getClient();\n  const handleChange = () => callback(getNetwork());\n  const unsubscribe = client2.subscribe(_ref54 => {\n    let {\n      data,\n      chains\n    } = _ref54;\n    return selector({\n      chainId: data?.chain?.id,\n      chains\n    });\n  }, handleChange, {\n    equalityFn: shallow5\n  });\n  return unsubscribe;\n}\n\n// src/actions/accounts/watchSigner.ts\nimport { shallow as shallow6 } from \"zustand/shallow\";\nfunction watchSigner(_ref55, callback) {\n  let {\n    chainId\n  } = _ref55;\n  const client2 = getClient();\n  const handleChange = async () => {\n    const signer = await fetchSigner({\n      chainId\n    });\n    if (!getClient().connector) return callback(null);\n    return callback(signer);\n  };\n  const unsubscribe = client2.subscribe(_ref56 => {\n    let {\n      data,\n      connector\n    } = _ref56;\n    return {\n      account: data?.account,\n      chainId: data?.chain?.id,\n      connector\n    };\n  }, handleChange, {\n    equalityFn: shallow6\n  });\n  return unsubscribe;\n}\n\n// src/errors.ts\nvar RpcError = class extends Error {\n  constructor(message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!Number.isInteger(code)) throw new Error('\"code\" must be an integer.');\n    if (!message || typeof message !== \"string\") throw new Error('\"message\" must be a nonempty string.');\n    super(message);\n    this.cause = cause;\n    this.code = code;\n    this.data = data;\n  }\n};\nvar ProviderRpcError = class extends RpcError {\n  constructor(message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!(Number.isInteger(code) && code >= 1e3 && code <= 4999)) throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    super(message, {\n      cause,\n      code,\n      data\n    });\n  }\n};\nvar AddChainError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"AddChainError\";\n    this.message = \"Error adding chain\";\n  }\n};\nvar ChainDoesNotSupportMulticallError = class extends Error {\n  constructor(_ref57) {\n    let {\n      blockNumber,\n      chain\n    } = _ref57;\n    super(`Chain \"${chain.name}\" does not support multicall${blockNumber ? ` on block ${blockNumber}` : \"\"}.`);\n    this.name = \"ChainDoesNotSupportMulticall\";\n  }\n};\nvar ChainMismatchError = class extends Error {\n  constructor(_ref58) {\n    let {\n      activeChain,\n      targetChain\n    } = _ref58;\n    super(`Chain mismatch: Expected \"${targetChain}\", received \"${activeChain}\".`);\n    this.name = \"ChainMismatchError\";\n  }\n};\nvar ChainNotConfiguredError = class extends Error {\n  constructor(_ref59) {\n    let {\n      chainId,\n      connectorId\n    } = _ref59;\n    super(`Chain \"${chainId}\" not configured for connector \"${connectorId}\".`);\n    this.name = \"ChainNotConfigured\";\n  }\n};\nvar ConnectorAlreadyConnectedError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorAlreadyConnectedError\";\n    this.message = \"Connector already connected\";\n  }\n};\nvar ConnectorNotFoundError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ConnectorNotFoundError\";\n    this.message = \"Connector not found\";\n  }\n};\nvar ContractMethodDoesNotExistError = class extends Error {\n  constructor(_ref60) {\n    let {\n      address,\n      chainId,\n      functionName\n    } = _ref60;\n    const {\n      chains,\n      network\n    } = getProvider();\n    const chain = chains?.find(_ref61 => {\n      let {\n        id\n      } = _ref61;\n      return id === (chainId || network.chainId);\n    });\n    const blockExplorer = chain?.blockExplorers?.default;\n    super([`Function \"${functionName}\" on contract \"${address}\" does not exist.`, ...(blockExplorer ? [\"\", `${blockExplorer?.name}: ${blockExplorer?.url}/address/${address}#readContract`] : [])].join(\"\\n\"));\n    this.name = \"ContractMethodDoesNotExistError\";\n  }\n};\nvar ContractMethodNoResultError = class extends Error {\n  constructor(_ref62) {\n    let {\n      address,\n      args,\n      chainId,\n      functionName\n    } = _ref62;\n    super([\"Contract read returned an empty response. This could be due to any of the following:\", `- The contract does not have the function \"${functionName}\",`, \"- The parameters passed to the contract function may be invalid, or\", \"- The address is not a contract.\", \"\", `Config:`, JSON.stringify({\n      address,\n      abi: \"...\",\n      functionName,\n      chainId,\n      args\n    }, null, 2)].join(\"\\n\"));\n    this.name = \"ContractMethodNoResultError\";\n  }\n};\nvar ContractMethodRevertedError = class extends Error {\n  constructor(_ref63) {\n    let {\n      address,\n      args,\n      chainId,\n      functionName,\n      errorMessage\n    } = _ref63;\n    super([\"Contract method reverted with an error.\", \"\", `Config:`, JSON.stringify({\n      address,\n      abi: \"...\",\n      functionName,\n      chainId,\n      args\n    }, null, 2), \"\", `Details: ${errorMessage}`].join(\"\\n\"));\n    this.name = \"ContractMethodRevertedError\";\n  }\n};\nvar ContractResultDecodeError = class extends Error {\n  constructor(_ref64) {\n    let {\n      address,\n      args,\n      chainId,\n      functionName,\n      errorMessage\n    } = _ref64;\n    super([\"Failed to decode contract function result.\", \"\", `Config:`, JSON.stringify({\n      address,\n      abi: \"...\",\n      functionName,\n      chainId,\n      args\n    }, null, 2), \"\", `Details: ${errorMessage}`].join(\"\\n\"));\n    this.name = \"ContractResultDecodeError\";\n  }\n};\nvar ProviderChainsNotFound = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = \"ProviderChainsNotFound\";\n    this.message = [\"No chains were found on the wagmi provider. Some functions that require a chain may not work.\", \"\", \"It is recommended to add a list of chains to the provider in `createClient`.\", \"\", \"Example:\", \"\", \"```\", \"import { getDefaultProvider } from 'ethers'\", \"import { chain, createClient } from 'wagmi'\", \"\", \"createClient({\", \"  provider: Object.assign(getDefaultProvider(), { chains: [chain.mainnet] })\", \"})\", \"```\"].join(\"\\n\");\n  }\n};\nvar ResourceUnavailableError = class extends RpcError {\n  constructor(cause) {\n    super(\"Resource unavailable\", {\n      cause,\n      code: -32002\n    });\n    this.name = \"ResourceUnavailable\";\n  }\n};\nvar SwitchChainError = class extends ProviderRpcError {\n  constructor(cause) {\n    super(\"Error switching chain\", {\n      cause,\n      code: 4902\n    });\n    this.name = \"SwitchChainError\";\n  }\n};\nvar SwitchChainNotSupportedError = class extends Error {\n  constructor(_ref65) {\n    let {\n      connector\n    } = _ref65;\n    super(`\"${connector.name}\" does not support programmatic chain switching.`);\n    this.name = \"SwitchChainNotSupportedError\";\n  }\n};\nvar UserRejectedRequestError = class extends ProviderRpcError {\n  constructor(cause) {\n    super(\"User rejected request\", {\n      cause,\n      code: 4001\n    });\n    this.name = \"UserRejectedRequestError\";\n  }\n};\nexport { configureChains, RpcError, ProviderRpcError, AddChainError, ChainDoesNotSupportMulticallError, ChainMismatchError, ChainNotConfiguredError, ConnectorAlreadyConnectedError, ConnectorNotFoundError, ContractMethodDoesNotExistError, ContractMethodNoResultError, ContractMethodRevertedError, ContractResultDecodeError, ProviderChainsNotFound, ResourceUnavailableError, SwitchChainError, SwitchChainNotSupportedError, UserRejectedRequestError, debounce, deepEqual, deserialize, minimizeContractInterface, normalizeChainId, parseContractResult, serialize, noopStorage, createStorage, Client, createClient, getClient, connect, disconnect, erc20ABI, erc721ABI, erc4626ABI, units, fetchToken, getContract, prepareWriteContract, getProvider, getWebSocketProvider, watchProvider, watchWebSocketProvider, multicall, readContract, readContracts, watchContractEvent, fetchBlockNumber, watchBlockNumber, watchMulticall, watchReadContract, watchReadContracts, fetchTransaction, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, prepareSendTransaction, sendTransaction, fetchFeeData, waitForTransaction, watchPendingTransactions, writeContract, fetchBalance, fetchSigner, getAccount, getNetwork, signMessage, signTypedData, switchNetwork, watchAccount, watchNetwork, watchSigner };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}