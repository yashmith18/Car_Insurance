{"ast":null,"code":"import drain from 'it-drain';\nimport filter from 'it-filter';\nimport take from 'it-take';\nimport all from 'it-all';\nconst sortAll = (iterable, sorter) => {\n  return async function* () {\n    const values = await all(iterable);\n    yield* values.sort(sorter);\n  }();\n};\nexport class BaseBlockstore {\n  open() {\n    return Promise.reject(new Error('.open is not implemented'));\n  }\n  close() {\n    return Promise.reject(new Error('.close is not implemented'));\n  }\n  put(key, val, options) {\n    return Promise.reject(new Error('.put is not implemented'));\n  }\n  get(key, options) {\n    return Promise.reject(new Error('.get is not implemented'));\n  }\n  has(key, options) {\n    return Promise.reject(new Error('.has is not implemented'));\n  }\n  delete(key, options) {\n    return Promise.reject(new Error('.delete is not implemented'));\n  }\n  putMany(source) {\n    try {\n      var _this = this;\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return async function* () {\n        for await (const {\n          key,\n          value\n        } of source) {\n          await _this.put(key, value, options);\n          yield {\n            key,\n            value\n          };\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  getMany(source) {\n    try {\n      var _this2 = this;\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return async function* () {\n        for await (const key of source) {\n          yield _this2.get(key, options);\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  deleteMany(source) {\n    try {\n      var _this3 = this;\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return async function* () {\n        for await (const key of source) {\n          await _this3.delete(key, options);\n          yield key;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  batch() {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n      delete(key) {\n        dels.push(key);\n      },\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  async *_all(q, options) {\n    throw new Error('._all is not implemented');\n  }\n  async *_allKeys(q, options) {\n    throw new Error('._allKeys is not implemented');\n  }\n  query(q, options) {\n    let it = this._all(q, options);\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix || ''));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= (q.offset || 0));\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n  queryKeys(q, options) {\n    let it = this._allKeys(q, options);\n    if (q.prefix != null) {\n      it = filter(it, cid => cid.toString().startsWith(q.prefix || ''));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}