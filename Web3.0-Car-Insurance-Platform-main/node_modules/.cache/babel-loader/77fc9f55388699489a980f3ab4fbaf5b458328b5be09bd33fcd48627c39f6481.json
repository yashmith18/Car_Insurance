{"ast":null,"code":"import { CarReader, CarWriter } from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [pb, raw, cbor, ...(options.decoders || [])];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1) throw new Error(`unexpected number of roots: ${roots.length}`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out) yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock) throw new Error(`missing block for ${cid}`);\n    const {\n      bytes\n    } = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder) throw new Error(`missing decoder for ${cid.code}`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  _cars(cid) {\n    try {\n      var _this = this;\n      let parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      let channel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      return async function* () {\n        const block = await _this._get(cid);\n        channel = channel || Object.assign(CarWriter.create(cid), {\n          size: 0\n        });\n        if (channel.size > 0 && channel.size + block.bytes.byteLength >= _this._targetSize) {\n          channel.writer.close();\n          const {\n            out\n          } = channel;\n          channel = newCar(parents);\n          yield {\n            channel,\n            out\n          };\n        }\n        parents = parents.concat(block);\n        channel.size += block.bytes.byteLength;\n        channel.writer.put(block);\n        for (const [, cid] of block.links()) {\n          for await (const val of _this._cars(cid, parents, channel)) {\n            channel = val.channel;\n            yield val;\n          }\n        }\n        if (!channel) {\n          throw new Error('missing CAR writer channel');\n        }\n        yield {\n          channel\n        };\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), {\n    size: parents.reduce((size, b) => size + b.bytes.byteLength, 0)\n  });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}