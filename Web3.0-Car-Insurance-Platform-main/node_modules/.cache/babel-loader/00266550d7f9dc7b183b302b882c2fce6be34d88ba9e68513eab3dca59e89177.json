{"ast":null,"code":"import Ot, { EventEmitter as A } from \"events\";\nimport ce from \"pino\";\nimport At from \"@walletconnect/keyvaluestorage\";\nimport { HEARTBEAT_EVENTS as G, HeartBeat as zt } from \"@walletconnect/heartbeat\";\nimport { generateChildLogger as w, getLoggerContext as v, getDefaultLoggerOptions as ue } from \"@walletconnect/logger\";\nimport { IMessageTracker as Nt, IPublisher as Ut, ISubscriber as Lt, IRelayer as Ft, IStore as Mt, IJsonRpcHistory as Kt, IExpirer as $t, ICore as kt } from \"@walletconnect/types\";\nimport { safeJsonStringify as Bt, safeJsonParse as jt } from \"@walletconnect/safe-json\";\nimport * as $ from \"@walletconnect/relay-auth\";\nimport { getInternalError as c, mapToObj as le, objToMap as de, generateKeyPair as Vt, generateRandomBytes32 as Y, deriveSymKey as qt, hashKey as Gt, validateEncoding as Yt, isTypeOneEnvelope as ge, encrypt as Jt, validateDecoding as Ht, decrypt as Xt, deserialize as Wt, decodeTypeByte as Zt, hashMessage as J, getRelayProtocolName as H, createExpiringPromise as pe, getRelayProtocolApi as X, isUndefined as W, getSdkError as L, formatRelayRpcUrl as Qt, isProposalStruct as ei, isSessionStruct as ti, TYPE_1 as ii, calcExpiry as Z, formatUri as si, parseUri as ri, createDelayedPromise as ni, engineEvent as Q, isExpired as De, isValidParams as ee, isValidUrl as ai, isValidString as oi, parseExpirerTarget as hi, formatTopicTarget as ci, formatIdTarget as ui } from \"@walletconnect/utils\";\nimport { ONE_DAY as z, SIX_HOURS as li, ONE_SECOND as di, THIRTY_DAYS as te, FIVE_SECONDS as gi, THIRTY_SECONDS as ye, Watch as pi, toMiliseconds as be, FIVE_MINUTES as me } from \"@walletconnect/time\";\nimport { JsonRpcProvider as Di } from \"@walletconnect/jsonrpc-provider\";\nimport { isJsonRpcRequest as Ee, formatJsonRpcResult as fe, formatJsonRpcRequest as we, formatJsonRpcError as yi, isJsonRpcResult as bi, isJsonRpcError as ve, isJsonRpcResponse as mi } from \"@walletconnect/jsonrpc-utils\";\nimport Ei from \"@walletconnect/jsonrpc-ws-connection\";\nimport fi from \"lodash.isequal\";\nfunction wi(r, e) {\n  if (r.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;\n  for (var s = 0; s < r.length; s++) {\n    var n = r.charAt(s),\n      a = n.charCodeAt(0);\n    if (t[a] !== 255) throw new TypeError(n + \" is ambiguous\");\n    t[a] = s;\n  }\n  var o = r.length,\n    h = r.charAt(0),\n    d = Math.log(o) / Math.log(256),\n    l = Math.log(256) / Math.log(o);\n  function g(u) {\n    if (u instanceof Uint8Array || (ArrayBuffer.isView(u) ? u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength) : Array.isArray(u) && (u = Uint8Array.from(u))), !(u instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n    if (u.length === 0) return \"\";\n    for (var y = 0, O = 0, E = 0, _ = u.length; E !== _ && u[E] === 0;) E++, y++;\n    for (var R = (_ - E) * l + 1 >>> 0, b = new Uint8Array(R); E !== _;) {\n      for (var S = u[E], x = 0, f = R - 1; (S !== 0 || x < O) && f !== -1; f--, x++) S += 256 * b[f] >>> 0, b[f] = S % o >>> 0, S = S / o >>> 0;\n      if (S !== 0) throw new Error(\"Non-zero carry\");\n      O = x, E++;\n    }\n    for (var T = R - O; T !== R && b[T] === 0;) T++;\n    for (var K = h.repeat(y); T < R; ++T) K += r.charAt(b[T]);\n    return K;\n  }\n  function U(u) {\n    if (typeof u != \"string\") throw new TypeError(\"Expected String\");\n    if (u.length === 0) return new Uint8Array();\n    var y = 0;\n    if (u[y] !== \" \") {\n      for (var O = 0, E = 0; u[y] === h;) O++, y++;\n      for (var _ = (u.length - y) * d + 1 >>> 0, R = new Uint8Array(_); u[y];) {\n        var b = t[u.charCodeAt(y)];\n        if (b === 255) return;\n        for (var S = 0, x = _ - 1; (b !== 0 || S < E) && x !== -1; x--, S++) b += o * R[x] >>> 0, R[x] = b % 256 >>> 0, b = b / 256 >>> 0;\n        if (b !== 0) throw new Error(\"Non-zero carry\");\n        E = S, y++;\n      }\n      if (u[y] !== \" \") {\n        for (var f = _ - E; f !== _ && R[f] === 0;) f++;\n        for (var T = new Uint8Array(O + (_ - f)), K = O; f !== _;) T[K++] = R[f++];\n        return T;\n      }\n    }\n  }\n  function q(u) {\n    var y = U(u);\n    if (y) return y;\n    throw new Error(`Non-${e} character`);\n  }\n  return {\n    encode: g,\n    decodeUnsafe: U,\n    decode: q\n  };\n}\nvar vi = wi,\n  Ii = vi;\nconst Ie = r => {\n    if (r instanceof Uint8Array && r.constructor.name === \"Uint8Array\") return r;\n    if (r instanceof ArrayBuffer) return new Uint8Array(r);\n    if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  Ci = r => new TextEncoder().encode(r),\n  _i = r => new TextDecoder().decode(r);\nclass Ri {\n  constructor(e, t, i) {\n    this.name = e, this.prefix = t, this.baseEncode = i;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Si {\n  constructor(e, t, i) {\n    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;\n  }\n  decode(e) {\n    if (typeof e == \"string\") {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    } else throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return Ce(this, e);\n  }\n}\nclass Ti {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return Ce(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      i = this.decoders[t];\n    if (i) return i.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst Ce = (r, e) => new Ti({\n  ...(r.decoders || {\n    [r.prefix]: r\n  }),\n  ...(e.decoders || {\n    [e.prefix]: e\n  })\n});\nclass Pi {\n  constructor(e, t, i, s) {\n    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = s, this.encoder = new Ri(e, t, i), this.decoder = new Si(e, t, s);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst k = _ref => {\n    let {\n      name: r,\n      prefix: e,\n      encode: t,\n      decode: i\n    } = _ref;\n    return new Pi(r, e, t, i);\n  },\n  F = _ref2 => {\n    let {\n      prefix: r,\n      name: e,\n      alphabet: t\n    } = _ref2;\n    const {\n      encode: i,\n      decode: s\n    } = Ii(t, e);\n    return k({\n      prefix: r,\n      name: e,\n      encode: i,\n      decode: n => Ie(s(n))\n    });\n  },\n  xi = (r, e, t, i) => {\n    const s = {};\n    for (let l = 0; l < e.length; ++l) s[e[l]] = l;\n    let n = r.length;\n    for (; r[n - 1] === \"=\";) --n;\n    const a = new Uint8Array(n * t / 8 | 0);\n    let o = 0,\n      h = 0,\n      d = 0;\n    for (let l = 0; l < n; ++l) {\n      const g = s[r[l]];\n      if (g === void 0) throw new SyntaxError(`Non-${i} character`);\n      h = h << t | g, o += t, o >= 8 && (o -= 8, a[d++] = 255 & h >> o);\n    }\n    if (o >= t || 255 & h << 8 - o) throw new SyntaxError(\"Unexpected end of data\");\n    return a;\n  },\n  Oi = (r, e, t) => {\n    const i = e[e.length - 1] === \"=\",\n      s = (1 << t) - 1;\n    let n = \"\",\n      a = 0,\n      o = 0;\n    for (let h = 0; h < r.length; ++h) for (o = o << 8 | r[h], a += 8; a > t;) a -= t, n += e[s & o >> a];\n    if (a && (n += e[s & o << t - a]), i) for (; n.length * t & 7;) n += \"=\";\n    return n;\n  },\n  p = _ref3 => {\n    let {\n      name: r,\n      prefix: e,\n      bitsPerChar: t,\n      alphabet: i\n    } = _ref3;\n    return k({\n      prefix: e,\n      name: r,\n      encode(s) {\n        return Oi(s, i, t);\n      },\n      decode(s) {\n        return xi(s, i, t, r);\n      }\n    });\n  },\n  Ai = k({\n    prefix: \"\\0\",\n    name: \"identity\",\n    encode: r => _i(r),\n    decode: r => Ci(r)\n  });\nvar zi = Object.freeze({\n  __proto__: null,\n  identity: Ai\n});\nconst Ni = p({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar Ui = Object.freeze({\n  __proto__: null,\n  base2: Ni\n});\nconst Li = p({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar Fi = Object.freeze({\n  __proto__: null,\n  base8: Li\n});\nconst Mi = F({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar Ki = Object.freeze({\n  __proto__: null,\n  base10: Mi\n});\nconst $i = p({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  ki = p({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar Bi = Object.freeze({\n  __proto__: null,\n  base16: $i,\n  base16upper: ki\n});\nconst ji = p({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  Vi = p({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  qi = p({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  Gi = p({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  Yi = p({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  Ji = p({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  Hi = p({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  Xi = p({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  Wi = p({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar Zi = Object.freeze({\n  __proto__: null,\n  base32: ji,\n  base32upper: Vi,\n  base32pad: qi,\n  base32padupper: Gi,\n  base32hex: Yi,\n  base32hexupper: Ji,\n  base32hexpad: Hi,\n  base32hexpadupper: Xi,\n  base32z: Wi\n});\nconst Qi = F({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  es = F({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar ts = Object.freeze({\n  __proto__: null,\n  base36: Qi,\n  base36upper: es\n});\nconst is = F({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  ss = F({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar rs = Object.freeze({\n  __proto__: null,\n  base58btc: is,\n  base58flickr: ss\n});\nconst ns = p({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  as = p({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  os = p({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  hs = p({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar cs = Object.freeze({\n  __proto__: null,\n  base64: ns,\n  base64pad: as,\n  base64url: os,\n  base64urlpad: hs\n});\nconst _e = Array.from(\"\\u{1F680}\\u{1FA90}\\u2604\\u{1F6F0}\\u{1F30C}\\u{1F311}\\u{1F312}\\u{1F313}\\u{1F314}\\u{1F315}\\u{1F316}\\u{1F317}\\u{1F318}\\u{1F30D}\\u{1F30F}\\u{1F30E}\\u{1F409}\\u2600\\u{1F4BB}\\u{1F5A5}\\u{1F4BE}\\u{1F4BF}\\u{1F602}\\u2764\\u{1F60D}\\u{1F923}\\u{1F60A}\\u{1F64F}\\u{1F495}\\u{1F62D}\\u{1F618}\\u{1F44D}\\u{1F605}\\u{1F44F}\\u{1F601}\\u{1F525}\\u{1F970}\\u{1F494}\\u{1F496}\\u{1F499}\\u{1F622}\\u{1F914}\\u{1F606}\\u{1F644}\\u{1F4AA}\\u{1F609}\\u263A\\u{1F44C}\\u{1F917}\\u{1F49C}\\u{1F614}\\u{1F60E}\\u{1F607}\\u{1F339}\\u{1F926}\\u{1F389}\\u{1F49E}\\u270C\\u2728\\u{1F937}\\u{1F631}\\u{1F60C}\\u{1F338}\\u{1F64C}\\u{1F60B}\\u{1F497}\\u{1F49A}\\u{1F60F}\\u{1F49B}\\u{1F642}\\u{1F493}\\u{1F929}\\u{1F604}\\u{1F600}\\u{1F5A4}\\u{1F603}\\u{1F4AF}\\u{1F648}\\u{1F447}\\u{1F3B6}\\u{1F612}\\u{1F92D}\\u2763\\u{1F61C}\\u{1F48B}\\u{1F440}\\u{1F62A}\\u{1F611}\\u{1F4A5}\\u{1F64B}\\u{1F61E}\\u{1F629}\\u{1F621}\\u{1F92A}\\u{1F44A}\\u{1F973}\\u{1F625}\\u{1F924}\\u{1F449}\\u{1F483}\\u{1F633}\\u270B\\u{1F61A}\\u{1F61D}\\u{1F634}\\u{1F31F}\\u{1F62C}\\u{1F643}\\u{1F340}\\u{1F337}\\u{1F63B}\\u{1F613}\\u2B50\\u2705\\u{1F97A}\\u{1F308}\\u{1F608}\\u{1F918}\\u{1F4A6}\\u2714\\u{1F623}\\u{1F3C3}\\u{1F490}\\u2639\\u{1F38A}\\u{1F498}\\u{1F620}\\u261D\\u{1F615}\\u{1F33A}\\u{1F382}\\u{1F33B}\\u{1F610}\\u{1F595}\\u{1F49D}\\u{1F64A}\\u{1F639}\\u{1F5E3}\\u{1F4AB}\\u{1F480}\\u{1F451}\\u{1F3B5}\\u{1F91E}\\u{1F61B}\\u{1F534}\\u{1F624}\\u{1F33C}\\u{1F62B}\\u26BD\\u{1F919}\\u2615\\u{1F3C6}\\u{1F92B}\\u{1F448}\\u{1F62E}\\u{1F646}\\u{1F37B}\\u{1F343}\\u{1F436}\\u{1F481}\\u{1F632}\\u{1F33F}\\u{1F9E1}\\u{1F381}\\u26A1\\u{1F31E}\\u{1F388}\\u274C\\u270A\\u{1F44B}\\u{1F630}\\u{1F928}\\u{1F636}\\u{1F91D}\\u{1F6B6}\\u{1F4B0}\\u{1F353}\\u{1F4A2}\\u{1F91F}\\u{1F641}\\u{1F6A8}\\u{1F4A8}\\u{1F92C}\\u2708\\u{1F380}\\u{1F37A}\\u{1F913}\\u{1F619}\\u{1F49F}\\u{1F331}\\u{1F616}\\u{1F476}\\u{1F974}\\u25B6\\u27A1\\u2753\\u{1F48E}\\u{1F4B8}\\u2B07\\u{1F628}\\u{1F31A}\\u{1F98B}\\u{1F637}\\u{1F57A}\\u26A0\\u{1F645}\\u{1F61F}\\u{1F635}\\u{1F44E}\\u{1F932}\\u{1F920}\\u{1F927}\\u{1F4CC}\\u{1F535}\\u{1F485}\\u{1F9D0}\\u{1F43E}\\u{1F352}\\u{1F617}\\u{1F911}\\u{1F30A}\\u{1F92F}\\u{1F437}\\u260E\\u{1F4A7}\\u{1F62F}\\u{1F486}\\u{1F446}\\u{1F3A4}\\u{1F647}\\u{1F351}\\u2744\\u{1F334}\\u{1F4A3}\\u{1F438}\\u{1F48C}\\u{1F4CD}\\u{1F940}\\u{1F922}\\u{1F445}\\u{1F4A1}\\u{1F4A9}\\u{1F450}\\u{1F4F8}\\u{1F47B}\\u{1F910}\\u{1F92E}\\u{1F3BC}\\u{1F975}\\u{1F6A9}\\u{1F34E}\\u{1F34A}\\u{1F47C}\\u{1F48D}\\u{1F4E3}\\u{1F942}\"),\n  us = _e.reduce((r, e, t) => (r[t] = e, r), []),\n  ls = _e.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);\nfunction ds(r) {\n  return r.reduce((e, t) => (e += us[t], e), \"\");\n}\nfunction gs(r) {\n  const e = [];\n  for (const t of r) {\n    const i = ls[t.codePointAt(0)];\n    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);\n    e.push(i);\n  }\n  return new Uint8Array(e);\n}\nconst ps = k({\n  prefix: \"\\u{1F680}\",\n  name: \"base256emoji\",\n  encode: ds,\n  decode: gs\n});\nvar Ds = Object.freeze({\n    __proto__: null,\n    base256emoji: ps\n  }),\n  ys = Se,\n  Re = 128,\n  bs = 127,\n  ms = ~bs,\n  Es = Math.pow(2, 31);\nfunction Se(r, e, t) {\n  e = e || [], t = t || 0;\n  for (var i = t; r >= Es;) e[t++] = r & 255 | Re, r /= 128;\n  for (; r & ms;) e[t++] = r & 255 | Re, r >>>= 7;\n  return e[t] = r | 0, Se.bytes = t - i + 1, e;\n}\nvar fs = ie,\n  ws = 128,\n  Te = 127;\nfunction ie(r, i) {\n  var t = 0,\n    i = i || 0,\n    s = 0,\n    n = i,\n    a,\n    o = r.length;\n  do {\n    if (n >= o) throw ie.bytes = 0, new RangeError(\"Could not decode varint\");\n    a = r[n++], t += s < 28 ? (a & Te) << s : (a & Te) * Math.pow(2, s), s += 7;\n  } while (a >= ws);\n  return ie.bytes = n - i, t;\n}\nvar vs = Math.pow(2, 7),\n  Is = Math.pow(2, 14),\n  Cs = Math.pow(2, 21),\n  _s = Math.pow(2, 28),\n  Rs = Math.pow(2, 35),\n  Ss = Math.pow(2, 42),\n  Ts = Math.pow(2, 49),\n  Ps = Math.pow(2, 56),\n  xs = Math.pow(2, 63),\n  Os = function (r) {\n    return r < vs ? 1 : r < Is ? 2 : r < Cs ? 3 : r < _s ? 4 : r < Rs ? 5 : r < Ss ? 6 : r < Ts ? 7 : r < Ps ? 8 : r < xs ? 9 : 10;\n  },\n  As = {\n    encode: ys,\n    decode: fs,\n    encodingLength: Os\n  },\n  Pe = As;\nconst xe = function (r, e) {\n    let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    return Pe.encode(r, e, t), e;\n  },\n  Oe = r => Pe.encodingLength(r),\n  se = (r, e) => {\n    const t = e.byteLength,\n      i = Oe(r),\n      s = i + Oe(t),\n      n = new Uint8Array(s + t);\n    return xe(r, n, 0), xe(t, n, i), n.set(e, s), new zs(r, t, e, n);\n  };\nclass zs {\n  constructor(e, t, i, s) {\n    this.code = e, this.size = t, this.digest = i, this.bytes = s;\n  }\n}\nconst Ae = _ref4 => {\n  let {\n    name: r,\n    code: e,\n    encode: t\n  } = _ref4;\n  return new Ns(r, e, t);\n};\nclass Ns {\n  constructor(e, t, i) {\n    this.name = e, this.code = t, this.encode = i;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? se(this.code, t) : t.then(i => se(this.code, i));\n    } else throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst ze = r => async e => new Uint8Array(await crypto.subtle.digest(r, e)),\n  Us = Ae({\n    name: \"sha2-256\",\n    code: 18,\n    encode: ze(\"SHA-256\")\n  }),\n  Ls = Ae({\n    name: \"sha2-512\",\n    code: 19,\n    encode: ze(\"SHA-512\")\n  });\nvar Fs = Object.freeze({\n  __proto__: null,\n  sha256: Us,\n  sha512: Ls\n});\nconst Ne = 0,\n  Ms = \"identity\",\n  Ue = Ie,\n  Ks = r => se(Ne, Ue(r)),\n  $s = {\n    code: Ne,\n    name: Ms,\n    encode: Ue,\n    digest: Ks\n  };\nvar ks = Object.freeze({\n  __proto__: null,\n  identity: $s\n});\nnew TextEncoder(), new TextDecoder();\nconst Le = {\n  ...zi,\n  ...Ui,\n  ...Fi,\n  ...Ki,\n  ...Bi,\n  ...Zi,\n  ...ts,\n  ...rs,\n  ...cs,\n  ...Ds\n};\n({\n  ...Fs,\n  ...ks\n});\nfunction Bs() {\n  let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);\n}\nfunction Fe(r, e, t, i) {\n  return {\n    name: r,\n    prefix: e,\n    encoder: {\n      name: r,\n      prefix: e,\n      encode: t\n    },\n    decoder: {\n      decode: i\n    }\n  };\n}\nconst Me = Fe(\"utf8\", \"u\", r => \"u\" + new TextDecoder(\"utf8\").decode(r), r => new TextEncoder().encode(r.substring(1))),\n  re = Fe(\"ascii\", \"a\", r => {\n    let e = \"a\";\n    for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);\n    return e;\n  }, r => {\n    r = r.substring(1);\n    const e = Bs(r.length);\n    for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);\n    return e;\n  }),\n  js = {\n    utf8: Me,\n    \"utf-8\": Me,\n    hex: Le.base16,\n    latin1: re,\n    ascii: re,\n    binary: re,\n    ...Le\n  };\nfunction Vs(r) {\n  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n  const t = js[e];\n  if (!t) throw new Error(`Unsupported encoding \"${e}\"`);\n  return (e === \"utf8\" || e === \"utf-8\") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, \"utf8\") : t.decoder.decode(`${t.prefix}${r}`);\n}\nconst ne = \"wc\",\n  Ke = 2,\n  B = \"core\",\n  P = `${ne}@${2}:${B}:`,\n  $e = {\n    name: B,\n    logger: \"error\"\n  },\n  ke = {\n    database: \":memory:\"\n  },\n  Be = \"crypto\",\n  ae = \"client_ed25519_seed\",\n  je = z,\n  Ve = \"keychain\",\n  qe = \"0.3\",\n  Ge = \"messages\",\n  Ye = \"0.3\",\n  Je = li,\n  He = \"publisher\",\n  Xe = \"irn\",\n  We = \"error\",\n  Ze = \"wss://relay.walletconnect.com\",\n  Qe = \"relayer\",\n  D = {\n    message: \"relayer_message\",\n    connect: \"relayer_connect\",\n    disconnect: \"relayer_disconnect\",\n    error: \"relayer_error\",\n    connection_stalled: \"relayer_connection_stalled\",\n    transport_closed: \"relayer_transport_closed\",\n    publish: \"relayer_publish\"\n  },\n  et = \"_subscription\",\n  M = {\n    payload: \"payload\",\n    connect: \"connect\",\n    disconnect: \"disconnect\",\n    error: \"error\"\n  },\n  oe = di,\n  qs = {\n    database: \":memory:\"\n  },\n  tt = \"2.3.0\",\n  it = \"0.3\",\n  I = {\n    created: \"subscription_created\",\n    deleted: \"subscription_deleted\",\n    expired: \"subscription_expired\",\n    disabled: \"subscription_disabled\",\n    sync: \"subscription_sync\",\n    resubscribed: \"subscription_resubscribed\"\n  },\n  Gs = te,\n  st = \"subscription\",\n  rt = \"0.3\",\n  nt = gi * 1e3,\n  at = \"pairing\",\n  ot = \"0.3\",\n  Ys = te,\n  N = {\n    wc_pairingDelete: {\n      req: {\n        ttl: z,\n        prompt: !1,\n        tag: 1e3\n      },\n      res: {\n        ttl: z,\n        prompt: !1,\n        tag: 1001\n      }\n    },\n    wc_pairingPing: {\n      req: {\n        ttl: ye,\n        prompt: !1,\n        tag: 1002\n      },\n      res: {\n        ttl: ye,\n        prompt: !1,\n        tag: 1003\n      }\n    },\n    unregistered_method: {\n      req: {\n        ttl: z,\n        prompt: !1,\n        tag: 0\n      },\n      res: {\n        ttl: z,\n        prompt: !1,\n        tag: 0\n      }\n    }\n  },\n  C = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  ht = \"history\",\n  ct = \"0.3\",\n  ut = \"expirer\",\n  m = {\n    created: \"expirer_created\",\n    deleted: \"expirer_deleted\",\n    expired: \"expirer_expired\",\n    sync: \"expirer_sync\"\n  },\n  lt = \"0.3\",\n  Js = z;\nclass dt {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.keychain = new Map(), this.name = Ve, this.version = qe, this.initialized = !1, this.storagePrefix = P, this.init = async () => {\n      if (!this.initialized) {\n        const i = await this.getKeyChain();\n        typeof i < \"u\" && (this.keychain = i), this.initialized = !0;\n      }\n    }, this.has = i => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, s) => {\n      this.isInitialized(), this.keychain.set(i, s), await this.persist();\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.keychain.get(i);\n      if (typeof s > \"u\") {\n        const {\n          message: n\n        } = c(\"NO_MATCHING_KEY\", `${this.name}: ${i}`);\n        throw new Error(n);\n      }\n      return s;\n    }, this.del = async i => {\n      this.isInitialized(), this.keychain.delete(i), await this.persist();\n    }, this.core = e, this.logger = w(t, this.name);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setKeyChain(e) {\n    await this.core.storage.setItem(this.storageKey, le(e));\n  }\n  async getKeyChain() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? de(e) : void 0;\n  }\n  async persist() {\n    await this.setKeyChain(this.keychain);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass gt {\n  constructor(e, t, i) {\n    this.core = e, this.logger = t, this.name = Be, this.initialized = !1, this.init = async () => {\n      this.initialized || (await this.keychain.init(), this.initialized = !0);\n    }, this.hasKeys = s => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {\n      this.isInitialized();\n      const s = await this.getClientSeed(),\n        n = $.generateKeyPair(s);\n      return $.encodeIss(n.publicKey);\n    }, this.generateKeyPair = () => {\n      this.isInitialized();\n      const s = Vt();\n      return this.setPrivateKey(s.publicKey, s.privateKey);\n    }, this.signJWT = async s => {\n      this.isInitialized();\n      const n = await this.getClientSeed(),\n        a = $.generateKeyPair(n),\n        o = Y(),\n        h = je;\n      return await $.signJWT(o, s, h, a);\n    }, this.generateSharedKey = (s, n, a) => {\n      this.isInitialized();\n      const o = this.getPrivateKey(s),\n        h = qt(o, n);\n      return this.setSymKey(h, a);\n    }, this.setSymKey = async (s, n) => {\n      this.isInitialized();\n      const a = n || Gt(s);\n      return await this.keychain.set(a, s), a;\n    }, this.deleteKeyPair = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.deleteSymKey = async s => {\n      this.isInitialized(), await this.keychain.del(s);\n    }, this.encode = async (s, n, a) => {\n      this.isInitialized();\n      const o = Yt(a),\n        h = Bt(n);\n      if (ge(o)) {\n        const U = o.senderPublicKey,\n          q = o.receiverPublicKey;\n        s = await this.generateSharedKey(U, q);\n      }\n      const d = this.getSymKey(s),\n        {\n          type: l,\n          senderPublicKey: g\n        } = o;\n      return Jt({\n        type: l,\n        symKey: d,\n        message: h,\n        senderPublicKey: g\n      });\n    }, this.decode = async (s, n, a) => {\n      this.isInitialized();\n      const o = Ht(n, a);\n      if (ge(o)) {\n        const l = o.receiverPublicKey,\n          g = o.senderPublicKey;\n        s = await this.generateSharedKey(l, g);\n      }\n      const h = this.getSymKey(s),\n        d = Xt({\n          symKey: h,\n          encoded: n\n        });\n      return jt(d);\n    }, this.core = e, this.logger = w(t, this.name), this.keychain = i || new dt(this.core, this.logger);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  getPayloadType(e) {\n    const t = Wt(e);\n    return Zt(t.type);\n  }\n  async setPrivateKey(e, t) {\n    return await this.keychain.set(e, t), e;\n  }\n  getPrivateKey(e) {\n    return this.keychain.get(e);\n  }\n  async getClientSeed() {\n    let e = \"\";\n    try {\n      e = this.keychain.get(ae);\n    } catch {\n      e = Y(), await this.keychain.set(ae, e);\n    }\n    return Vs(e, \"base16\");\n  }\n  getSymKey(e) {\n    return this.keychain.get(e);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass pt extends Nt {\n  constructor(e, t) {\n    super(e, t), this.logger = e, this.core = t, this.messages = new Map(), this.name = Ge, this.version = Ye, this.initialized = !1, this.storagePrefix = P, this.init = async () => {\n      if (!this.initialized) {\n        this.logger.trace(\"Initialized\");\n        try {\n          const i = await this.getRelayerMessages();\n          typeof i < \"u\" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n            type: \"method\",\n            method: \"restore\",\n            size: this.messages.size\n          });\n        } catch (i) {\n          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);\n        } finally {\n          this.initialized = !0;\n        }\n      }\n    }, this.set = async (i, s) => {\n      this.isInitialized();\n      const n = J(s);\n      let a = this.messages.get(i);\n      return typeof a > \"u\" && (a = {}), typeof a[n] < \"u\" || (a[n] = s, this.messages.set(i, a), await this.persist()), n;\n    }, this.get = i => {\n      this.isInitialized();\n      let s = this.messages.get(i);\n      return typeof s > \"u\" && (s = {}), s;\n    }, this.has = (i, s) => {\n      this.isInitialized();\n      const n = this.get(i),\n        a = J(s);\n      return typeof n[a] < \"u\";\n    }, this.del = async i => {\n      this.isInitialized(), this.messages.delete(i), await this.persist();\n    }, this.logger = w(e, this.name), this.core = t;\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  async setRelayerMessages(e) {\n    await this.core.storage.setItem(this.storageKey, le(e));\n  }\n  async getRelayerMessages() {\n    const e = await this.core.storage.getItem(this.storageKey);\n    return typeof e < \"u\" ? de(e) : void 0;\n  }\n  async persist() {\n    await this.setRelayerMessages(this.messages);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass Hs extends Ut {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.events = new A(), this.name = He, this.queue = new Map(), this.publishTimeout = 1e4, this.publish = async (i, s, n) => {\n      this.logger.debug(\"Publishing Payload\"), this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic: i,\n          message: s,\n          opts: n\n        }\n      });\n      try {\n        const a = n?.ttl || Je,\n          o = H(n),\n          h = n?.prompt || !1,\n          d = n?.tag || 0,\n          l = {\n            topic: i,\n            message: s,\n            opts: {\n              ttl: a,\n              relay: o,\n              prompt: h,\n              tag: d\n            }\n          },\n          g = J(s);\n        this.queue.set(g, l);\n        try {\n          await await pe(this.rpcPublish(i, s, a, o, h, d), this.publishTimeout), this.relayer.events.emit(D.publish, l);\n        } catch {\n          this.logger.debug(\"Publishing Payload stalled\"), this.relayer.events.emit(D.connection_stalled);\n          return;\n        }\n        this.onPublish(g, l), this.logger.debug(\"Successfully Published Payload\"), this.logger.trace({\n          type: \"method\",\n          method: \"publish\",\n          params: {\n            topic: i,\n            message: s,\n            opts: n\n          }\n        });\n      } catch (a) {\n        throw this.logger.debug(\"Failed to Publish Payload\"), this.logger.error(a), a;\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.relayer = e, this.logger = w(t, this.name), this.registerEventListeners();\n  }\n  get context() {\n    return v(this.logger);\n  }\n  rpcPublish(e, t, i, s, n, a) {\n    var o, h, d, l;\n    const g = {\n      method: X(s.protocol).publish,\n      params: {\n        topic: e,\n        message: t,\n        ttl: i,\n        prompt: n,\n        tag: a\n      }\n    };\n    return W((o = g.params) == null ? void 0 : o.prompt) && ((h = g.params) == null || delete h.prompt), W((d = g.params) == null ? void 0 : d.tag) && ((l = g.params) == null || delete l.tag), this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"message\",\n      direction: \"outgoing\",\n      request: g\n    }), this.relayer.provider.request(g);\n  }\n  onPublish(e, t) {\n    this.queue.delete(e);\n  }\n  checkQueue() {\n    this.queue.forEach(async e => {\n      const {\n        topic: t,\n        message: i,\n        opts: s\n      } = e;\n      await this.publish(t, i, s);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(G.pulse, () => {\n      this.checkQueue();\n    });\n  }\n}\nclass Xs {\n  constructor() {\n    this.map = new Map(), this.set = (e, t) => {\n      const i = this.get(e);\n      this.exists(e, t) || this.map.set(e, [...i, t]);\n    }, this.get = e => this.map.get(e) || [], this.exists = (e, t) => this.get(e).includes(t), this.delete = (e, t) => {\n      if (typeof t > \"u\") {\n        this.map.delete(e);\n        return;\n      }\n      if (!this.map.has(e)) return;\n      const i = this.get(e);\n      if (!this.exists(e, t)) return;\n      const s = i.filter(n => n !== t);\n      if (!s.length) {\n        this.map.delete(e);\n        return;\n      }\n      this.map.set(e, s);\n    }, this.clear = () => {\n      this.map.clear();\n    };\n  }\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n}\nvar Ws = Object.defineProperty,\n  Zs = Object.defineProperties,\n  Qs = Object.getOwnPropertyDescriptors,\n  Dt = Object.getOwnPropertySymbols,\n  er = Object.prototype.hasOwnProperty,\n  tr = Object.prototype.propertyIsEnumerable,\n  yt = (r, e, t) => e in r ? Ws(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  j = (r, e) => {\n    for (var t in e || (e = {})) er.call(e, t) && yt(r, t, e[t]);\n    if (Dt) for (var t of Dt(e)) tr.call(e, t) && yt(r, t, e[t]);\n    return r;\n  },\n  he = (r, e) => Zs(r, Qs(e));\nclass bt extends Lt {\n  constructor(e, t) {\n    super(e, t), this.relayer = e, this.logger = t, this.subscriptions = new Map(), this.topicMap = new Xs(), this.events = new A(), this.name = st, this.version = rt, this.pending = new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = \"pending_sub_watch_label\", this.pendingSubInterval = 20, this.storagePrefix = P, this.subscribeTimeout = 1e4, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restart(), this.registerEventListeners(), this.onEnable());\n    }, this.subscribe = async (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Subscribing Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic: i,\n          opts: s\n        }\n      });\n      try {\n        const n = H(s),\n          a = {\n            topic: i,\n            relay: n\n          };\n        this.pending.set(i, a);\n        const o = await this.rpcSubscribe(i, n);\n        return this.onSubscribe(o, a), this.logger.debug(\"Successfully Subscribed Topic\"), this.logger.trace({\n          type: \"method\",\n          method: \"subscribe\",\n          params: {\n            topic: i,\n            opts: s\n          }\n        }), o;\n      } catch (n) {\n        throw this.logger.debug(\"Failed to Subscribe Topic\"), this.logger.error(n), n;\n      }\n    }, this.unsubscribe = async (i, s) => {\n      this.isInitialized(), typeof s?.id < \"u\" ? await this.unsubscribeById(i, s.id, s) : await this.unsubscribeByTopic(i, s);\n    }, this.isSubscribed = async i => this.topics.includes(i) ? !0 : await new Promise((s, n) => {\n      const a = new pi();\n      a.start(this.pendingSubscriptionWatchLabel);\n      const o = setInterval(() => {\n        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), s(!0)), a.elapsed(this.pendingSubscriptionWatchLabel) >= nt && (clearInterval(o), a.stop(this.pendingSubscriptionWatchLabel), n(!1));\n      }, this.pendingSubInterval);\n    }), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.restart = async () => {\n      await this.restore(), await this.reset();\n    }, this.relayer = e, this.logger = w(t, this.name);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.subscriptions.size;\n  }\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n  get topics() {\n    return this.topicMap.topics;\n  }\n  hasSubscription(e, t) {\n    let i = !1;\n    try {\n      i = this.getSubscription(e).topic === t;\n    } catch {}\n    return i;\n  }\n  onEnable() {\n    this.cached = [], this.initialized = !0;\n  }\n  onDisable() {\n    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear(), this.initialized = !1;\n  }\n  async unsubscribeByTopic(e, t) {\n    const i = this.topicMap.get(e);\n    await Promise.all(i.map(async s => await this.unsubscribeById(e, s, t)));\n  }\n  async unsubscribeById(e, t, i) {\n    this.logger.debug(\"Unsubscribing Topic\"), this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic: e,\n        id: t,\n        opts: i\n      }\n    });\n    try {\n      const s = H(i);\n      await this.rpcUnsubscribe(e, t, s);\n      const n = L(\"USER_DISCONNECTED\", `${this.name}, ${e}`);\n      await this.onUnsubscribe(e, t, n), this.logger.debug(\"Successfully Unsubscribed Topic\"), this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic: e,\n          id: t,\n          opts: i\n        }\n      });\n    } catch (s) {\n      throw this.logger.debug(\"Failed to Unsubscribe Topic\"), this.logger.error(s), s;\n    }\n  }\n  async rpcSubscribe(e, t) {\n    const i = {\n      method: X(t.protocol).subscribe,\n      params: {\n        topic: e\n      }\n    };\n    this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: i\n    });\n    let s;\n    try {\n      s = await await pe(this.relayer.provider.request(i), this.subscribeTimeout);\n    } catch {\n      this.logger.debug(\"Outgoing Relay Payload stalled\"), this.relayer.events.emit(D.connection_stalled);\n    }\n    return s;\n  }\n  rpcUnsubscribe(e, t, i) {\n    const s = {\n      method: X(i.protocol).unsubscribe,\n      params: {\n        topic: e,\n        id: t\n      }\n    };\n    return this.logger.debug(\"Outgoing Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request: s\n    }), this.relayer.provider.request(s);\n  }\n  onSubscribe(e, t) {\n    this.setSubscription(e, he(j({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  onResubscribe(e, t) {\n    this.addSubscription(e, he(j({}, t), {\n      id: e\n    })), this.pending.delete(t.topic);\n  }\n  async onUnsubscribe(e, t, i) {\n    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i), await this.relayer.messages.del(e);\n  }\n  async setRelayerSubscriptions(e) {\n    await this.relayer.core.storage.setItem(this.storageKey, e);\n  }\n  async getRelayerSubscriptions() {\n    return await this.relayer.core.storage.getItem(this.storageKey);\n  }\n  setSubscription(e, t) {\n    this.subscriptions.has(e) || (this.logger.debug(\"Setting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"setSubscription\",\n      id: e,\n      subscription: t\n    }), this.addSubscription(e, t));\n  }\n  addSubscription(e, t) {\n    this.subscriptions.set(e, j({}, t)), this.topicMap.set(t.topic, e), this.events.emit(I.created, t);\n  }\n  getSubscription(e) {\n    this.logger.debug(\"Getting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"getSubscription\",\n      id: e\n    });\n    const t = this.subscriptions.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  deleteSubscription(e, t) {\n    this.logger.debug(\"Deleting subscription\"), this.logger.trace({\n      type: \"method\",\n      method: \"deleteSubscription\",\n      id: e,\n      reason: t\n    });\n    const i = this.getSubscription(e);\n    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(I.deleted, he(j({}, i), {\n      reason: t\n    }));\n  }\n  async persist() {\n    await this.setRelayerSubscriptions(this.values), this.events.emit(I.sync);\n  }\n  async reset() {\n    this.cached.length && (await Promise.all(this.cached.map(async e => await this.resubscribe(e)))), this.events.emit(I.resubscribed);\n  }\n  async restore() {\n    try {\n      const e = await this.getRelayerSubscriptions();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.subscriptions.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);\n    }\n  }\n  async resubscribe(e) {\n    if (!this.ids.includes(e.id)) {\n      const {\n          topic: t,\n          relay: i\n        } = e,\n        s = {\n          topic: t,\n          relay: i\n        };\n      this.pending.set(s.topic, s);\n      const n = await this.rpcSubscribe(s.topic, s.relay);\n      this.onResubscribe(n, s);\n    }\n  }\n  async onConnect() {\n    await this.restart(), this.onEnable();\n  }\n  onDisconnect() {\n    this.onDisable();\n  }\n  checkPending() {\n    this.relayer.transportExplicitlyClosed || this.pending.forEach(async e => {\n      const t = await this.rpcSubscribe(e.topic, e.relay);\n      this.onSubscribe(t, e);\n    });\n  }\n  registerEventListeners() {\n    this.relayer.core.heartbeat.on(G.pulse, () => {\n      this.checkPending();\n    }), this.relayer.on(D.connect, async () => {\n      await this.onConnect();\n    }), this.relayer.on(D.disconnect, () => {\n      this.onDisconnect();\n    }), this.events.on(I.created, async e => {\n      const t = I.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    }), this.events.on(I.deleted, async e => {\n      const t = I.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), await this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar ir = Object.defineProperty,\n  mt = Object.getOwnPropertySymbols,\n  sr = Object.prototype.hasOwnProperty,\n  rr = Object.prototype.propertyIsEnumerable,\n  Et = (r, e, t) => e in r ? ir(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  nr = (r, e) => {\n    for (var t in e || (e = {})) sr.call(e, t) && Et(r, t, e[t]);\n    if (mt) for (var t of mt(e)) rr.call(e, t) && Et(r, t, e[t]);\n    return r;\n  };\nclass ft extends Ft {\n  constructor(e) {\n    super(e), this.protocol = \"wc\", this.version = 2, this.events = new A(), this.name = Qe, this.transportExplicitlyClosed = !1, this.initialized = !1, this.core = e.core, this.logger = typeof e.logger < \"u\" && typeof e.logger != \"string\" ? w(e.logger, this.name) : ce(ue({\n      level: e.logger || We\n    })), this.messages = new pt(this.logger, e.core), this.subscriber = new bt(this, this.logger), this.publisher = new Hs(this, this.logger), this.relayUrl = e?.relayUrl || Ze, this.projectId = e.projectId, this.provider = {};\n  }\n  async init() {\n    this.logger.trace(\"Initialized\"), this.provider = await this.createProvider(), await Promise.all([this.messages.init(), this.transportOpen(), this.subscriber.init()]), this.registerEventListeners(), this.initialized = !0;\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get connected() {\n    return this.provider.connection.connected;\n  }\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n  async publish(e, t, i) {\n    this.isInitialized(), await this.publisher.publish(e, t, i), await this.recordMessageEvent({\n      topic: e,\n      message: t\n    });\n  }\n  async subscribe(e, t) {\n    this.isInitialized();\n    let i = \"\";\n    return await Promise.all([new Promise(s => {\n      this.subscriber.once(I.created, n => {\n        n.topic === e && s();\n      });\n    }), new Promise(async s => {\n      i = await this.subscriber.subscribe(e, t), s();\n    })]), i;\n  }\n  async unsubscribe(e, t) {\n    this.isInitialized(), await this.subscriber.unsubscribe(e, t);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  async transportClose() {\n    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect()), this.events.emit(D.transport_closed);\n  }\n  async transportOpen(e) {\n    this.relayUrl = e || this.relayUrl, this.transportExplicitlyClosed = !1;\n    try {\n      await Promise.all([new Promise(t => {\n        this.initialized || t(), this.subscriber.once(I.resubscribed, () => {\n          t();\n        });\n      }), await Promise.race([this.provider.connect(), new Promise((t, i) => this.once(D.transport_closed, () => {\n        i(new Error(\"closeTransport called before connection was established\"));\n      }))])]);\n    } catch (t) {\n      const i = t;\n      if (!/socket hang up/i.test(i.message)) throw new Error(i.message);\n      this.logger.error(i), this.events.emit(D.transport_closed);\n    }\n  }\n  async restartTransport(e) {\n    await this.transportClose(), await new Promise(t => setTimeout(t, oe)), await this.transportOpen(e);\n  }\n  async createProvider() {\n    const e = await this.core.crypto.signJWT(this.relayUrl);\n    return new Di(new Ei(Qt({\n      sdkVersion: tt,\n      protocol: this.protocol,\n      version: this.version,\n      relayUrl: this.relayUrl,\n      projectId: this.projectId,\n      auth: e\n    })));\n  }\n  async recordMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    await this.messages.set(t, i);\n  }\n  async shouldIgnoreMessageEvent(e) {\n    const {\n      topic: t,\n      message: i\n    } = e;\n    return (await this.subscriber.isSubscribed(t)) ? this.messages.has(t, i) : !0;\n  }\n  async onProviderPayload(e) {\n    if (this.logger.debug(\"Incoming Relay Payload\"), this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload: e\n    }), Ee(e)) {\n      if (!e.method.endsWith(et)) return;\n      const t = e.params,\n        {\n          topic: i,\n          message: s\n        } = t.data,\n        n = {\n          topic: i,\n          message: s\n        };\n      this.logger.debug(\"Emitting Relayer Payload\"), this.logger.trace(nr({\n        type: \"event\",\n        event: t.id\n      }, n)), this.events.emit(t.id, n), await this.acknowledgePayload(e), await this.onMessageEvent(n);\n    }\n  }\n  async onMessageEvent(e) {\n    (await this.shouldIgnoreMessageEvent(e)) || (this.events.emit(D.message, e), await this.recordMessageEvent(e));\n  }\n  async acknowledgePayload(e) {\n    const t = fe(e.id, !0);\n    await this.provider.connection.send(t);\n  }\n  registerEventListeners() {\n    this.provider.on(M.payload, e => this.onProviderPayload(e)), this.provider.on(M.connect, () => {\n      this.events.emit(D.connect);\n    }), this.provider.on(M.disconnect, () => {\n      this.events.emit(D.disconnect), this.attemptToReconnect();\n    }), this.provider.on(M.error, e => this.events.emit(D.error, e)), this.events.on(D.connection_stalled, async () => {\n      await this.restartTransport();\n    });\n  }\n  attemptToReconnect() {\n    this.transportExplicitlyClosed || setTimeout(async () => {\n      await this.transportOpen();\n    }, be(oe));\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar ar = Object.defineProperty,\n  wt = Object.getOwnPropertySymbols,\n  or = Object.prototype.hasOwnProperty,\n  hr = Object.prototype.propertyIsEnumerable,\n  vt = (r, e, t) => e in r ? ar(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  It = (r, e) => {\n    for (var t in e || (e = {})) or.call(e, t) && vt(r, t, e[t]);\n    if (wt) for (var t of wt(e)) hr.call(e, t) && vt(r, t, e[t]);\n    return r;\n  };\nclass Ct extends Mt {\n  constructor(e, t, i) {\n    let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : P;\n    let n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n    super(e, t, i, s), this.core = e, this.logger = t, this.name = i, this.map = new Map(), this.version = it, this.cached = [], this.initialized = !1, this.storagePrefix = P, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(a => {\n        ei(a) ? this.map.set(a.id, a) : ti(a) ? this.map.set(a.topic, a) : this.getKey && a !== null && !W(a) && this.map.set(this.getKey(a), a);\n      }), this.cached = [], this.initialized = !0);\n    }, this.set = async (a, o) => {\n      this.isInitialized(), this.map.has(a) ? await this.update(a, o) : (this.logger.debug(\"Setting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        key: a,\n        value: o\n      }), this.map.set(a, o), await this.persist());\n    }, this.get = a => (this.isInitialized(), this.logger.debug(\"Getting value\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      key: a\n    }), this.getData(a)), this.getAll = a => (this.isInitialized(), a ? this.values.filter(o => Object.keys(a).every(h => fi(o[h], a[h]))) : this.values), this.update = async (a, o) => {\n      this.isInitialized(), this.logger.debug(\"Updating value\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        key: a,\n        update: o\n      });\n      const h = It(It({}, this.getData(a)), o);\n      this.map.set(a, h), await this.persist();\n    }, this.delete = async (a, o) => {\n      this.isInitialized(), this.map.has(a) && (this.logger.debug(\"Deleting value\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        key: a,\n        reason: o\n      }), this.map.delete(a), await this.persist());\n    }, this.logger = w(t, this.name), this.storagePrefix = s, this.getKey = n;\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.map.size;\n  }\n  get keys() {\n    return Array.from(this.map.keys());\n  }\n  get values() {\n    return Array.from(this.map.values());\n  }\n  async setDataStore(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getDataStore() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getData(e) {\n    const t = this.map.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setDataStore(this.values);\n  }\n  async restore() {\n    try {\n      const e = await this.getDataStore();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.map.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        value: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);\n    }\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass _t {\n  constructor(e, t) {\n    this.core = e, this.logger = t, this.name = at, this.version = ot, this.events = new Ot(), this.initialized = !1, this.storagePrefix = P, this.ignoredPayloadTypes = [ii], this.registeredMethods = [], this.init = async () => {\n      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace(\"Initialized\"));\n    }, this.register = _ref5 => {\n      let {\n        methods: i\n      } = _ref5;\n      this.isInitialized(), this.registeredMethods = [...new Set([...this.registeredMethods, ...i])];\n    }, this.create = async () => {\n      this.isInitialized();\n      const i = Y(),\n        s = await this.core.crypto.setSymKey(i),\n        n = Z(me),\n        a = {\n          protocol: Xe\n        },\n        o = {\n          topic: s,\n          expiry: n,\n          relay: a,\n          active: !1\n        },\n        h = si({\n          protocol: this.core.protocol,\n          version: this.core.version,\n          topic: s,\n          symKey: i,\n          relay: a\n        });\n      return await this.pairings.set(s, o), await this.core.relayer.subscribe(s), this.core.expirer.set(s, n), {\n        topic: s,\n        uri: h\n      };\n    }, this.pair = async i => {\n      this.isInitialized(), this.isValidPair(i);\n      const {\n          topic: s,\n          symKey: n,\n          relay: a\n        } = ri(i.uri),\n        o = Z(me),\n        h = {\n          topic: s,\n          relay: a,\n          expiry: o,\n          active: !1\n        };\n      return await this.pairings.set(s, h), await this.core.crypto.setSymKey(n, s), await this.core.relayer.subscribe(s, {\n        relay: a\n      }), this.core.expirer.set(s, o), i.activatePairing && (await this.activate({\n        topic: s\n      })), h;\n    }, this.activate = async _ref6 => {\n      let {\n        topic: i\n      } = _ref6;\n      this.isInitialized();\n      const s = Z(te);\n      await this.pairings.update(i, {\n        active: !0,\n        expiry: s\n      }), this.core.expirer.set(i, s);\n    }, this.ping = async i => {\n      this.isInitialized(), await this.isValidPing(i);\n      const {\n        topic: s\n      } = i;\n      if (this.pairings.keys.includes(s)) {\n        const n = await this.sendRequest(s, \"wc_pairingPing\", {}),\n          {\n            done: a,\n            resolve: o,\n            reject: h\n          } = ni();\n        this.events.once(Q(\"pairing_ping\", n), _ref7 => {\n          let {\n            error: d\n          } = _ref7;\n          d ? h(d) : o();\n        }), await a();\n      }\n    }, this.updateExpiry = async _ref8 => {\n      let {\n        topic: i,\n        expiry: s\n      } = _ref8;\n      this.isInitialized(), await this.pairings.update(i, {\n        expiry: s\n      });\n    }, this.updateMetadata = async _ref9 => {\n      let {\n        topic: i,\n        metadata: s\n      } = _ref9;\n      this.isInitialized(), await this.pairings.update(i, {\n        peerMetadata: s\n      });\n    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async i => {\n      this.isInitialized(), await this.isValidDisconnect(i);\n      const {\n        topic: s\n      } = i;\n      this.pairings.keys.includes(s) && (await this.sendRequest(s, \"wc_pairingDelete\", L(\"USER_DISCONNECTED\")), await this.deletePairing(s));\n    }, this.sendRequest = async (i, s, n) => {\n      const a = we(s, n),\n        o = await this.core.crypto.encode(i, a),\n        h = N[s].req;\n      return this.core.history.set(i, a), await this.core.relayer.publish(i, o, h), a.id;\n    }, this.sendResult = async (i, s, n) => {\n      const a = fe(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        d = N[h.request.method].res;\n      await this.core.relayer.publish(s, o, d), await this.core.history.resolve(a);\n    }, this.sendError = async (i, s, n) => {\n      const a = yi(i, n),\n        o = await this.core.crypto.encode(s, a),\n        h = await this.core.history.get(s, i),\n        d = N[h.request.method] ? N[h.request.method].res : N.unregistered_method.res;\n      await this.core.relayer.publish(s, o, d), await this.core.history.resolve(a);\n    }, this.deletePairing = async (i, s) => {\n      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, L(\"USER_DISCONNECTED\")), this.core.crypto.deleteSymKey(i), s ? Promise.resolve() : this.core.expirer.del(i)]);\n    }, this.cleanup = async () => {\n      const i = this.pairings.getAll().filter(s => De(s.expiry));\n      await Promise.all(i.map(s => this.deletePairing(s.topic)));\n    }, this.onRelayEventRequest = i => {\n      const {\n          topic: s,\n          payload: n\n        } = i,\n        a = n.method;\n      if (this.pairings.keys.includes(s)) switch (a) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingRequest(s, n);\n        case \"wc_pairingDelete\":\n          return this.onPairingDeleteRequest(s, n);\n        default:\n          return this.onUnknownRpcMethodRequest(s, n);\n      }\n    }, this.onRelayEventResponse = async i => {\n      const {\n          topic: s,\n          payload: n\n        } = i,\n        a = (await this.core.history.get(s, n.id)).request.method;\n      if (this.pairings.keys.includes(s)) switch (a) {\n        case \"wc_pairingPing\":\n          return this.onPairingPingResponse(s, n);\n        default:\n          return this.onUnknownRpcMethodResponse(a);\n      }\n    }, this.onPairingPingRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidPing({\n          topic: i\n        }), await this.sendResult(n, i, !0), this.events.emit(\"pairing_ping\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onPairingPingResponse = (i, s) => {\n      const {\n        id: n\n      } = s;\n      setTimeout(() => {\n        bi(s) ? this.events.emit(Q(\"pairing_ping\", n), {}) : ve(s) && this.events.emit(Q(\"pairing_ping\", n), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onPairingDeleteRequest = async (i, s) => {\n      const {\n        id: n\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: i\n        }), await this.sendResult(n, i, !0), await this.deletePairing(i), this.events.emit(\"pairing_delete\", {\n          id: n,\n          topic: i\n        });\n      } catch (a) {\n        await this.sendError(n, i, a), this.logger.error(a);\n      }\n    }, this.onUnknownRpcMethodRequest = async (i, s) => {\n      const {\n        id: n,\n        method: a\n      } = s;\n      try {\n        if (this.registeredMethods.includes(a)) return;\n        const o = L(\"WC_METHOD_UNSUPPORTED\", a);\n        await this.sendError(n, i, o), this.logger.error(o);\n      } catch (o) {\n        await this.sendError(n, i, o), this.logger.error(o);\n      }\n    }, this.onUnknownRpcMethodResponse = i => {\n      this.registeredMethods.includes(i) || this.logger.error(L(\"WC_METHOD_UNSUPPORTED\", i));\n    }, this.isValidPair = i => {\n      if (!ee(i)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pair() params: ${i}`);\n        throw new Error(s);\n      }\n      if (!ai(i.uri)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pair() uri: ${i.uri}`);\n        throw new Error(s);\n      }\n    }, this.isValidPing = async i => {\n      if (!ee(i)) {\n        const {\n          message: n\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidDisconnect = async i => {\n      if (!ee(i)) {\n        const {\n          message: n\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${i}`);\n        throw new Error(n);\n      }\n      const {\n        topic: s\n      } = i;\n      await this.isValidPairingTopic(s);\n    }, this.isValidPairingTopic = async i => {\n      if (!oi(i, !1)) {\n        const {\n          message: s\n        } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${i}`);\n        throw new Error(s);\n      }\n      if (!this.pairings.keys.includes(i)) {\n        const {\n          message: s\n        } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${i}`);\n        throw new Error(s);\n      }\n      if (De(this.pairings.get(i).expiry)) {\n        await this.deletePairing(i);\n        const {\n          message: s\n        } = c(\"EXPIRED\", `pairing topic: ${i}`);\n        throw new Error(s);\n      }\n    }, this.core = e, this.logger = w(t, this.name), this.pairings = new Ct(this.core, this.logger, this.name, this.storagePrefix);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n  registerRelayerEvents() {\n    this.core.relayer.on(D.message, async e => {\n      const {\n        topic: t,\n        message: i\n      } = e;\n      if (this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i))) return;\n      const s = await this.core.crypto.decode(t, i);\n      Ee(s) ? (this.core.history.set(t, s), this.onRelayEventRequest({\n        topic: t,\n        payload: s\n      })) : mi(s) && (await this.core.history.resolve(s), this.onRelayEventResponse({\n        topic: t,\n        payload: s\n      }));\n    });\n  }\n  registerExpirerEvents() {\n    this.core.expirer.on(m.expired, async e => {\n      const {\n        topic: t\n      } = hi(e.target);\n      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, !0), this.events.emit(\"pairing_expire\", {\n        topic: t\n      }));\n    });\n  }\n}\nclass Rt extends Kt {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.records = new Map(), this.events = new A(), this.name = ht, this.version = ct, this.cached = [], this.initialized = !1, this.storagePrefix = P, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.set = (i, s, n) => {\n      if (this.isInitialized(), this.logger.debug(\"Setting JSON-RPC request history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic: i,\n        request: s,\n        chainId: n\n      }), this.records.has(s.id)) return;\n      const a = {\n        id: s.id,\n        topic: i,\n        request: {\n          method: s.method,\n          params: s.params || null\n        },\n        chainId: n\n      };\n      this.records.set(a.id, a), this.events.emit(C.created, a);\n    }, this.resolve = async i => {\n      if (this.isInitialized(), this.logger.debug(\"Updating JSON-RPC response history record\"), this.logger.trace({\n        type: \"method\",\n        method: \"update\",\n        response: i\n      }), !this.records.has(i.id)) return;\n      const s = await this.getRecord(i.id);\n      typeof s.response > \"u\" && (s.response = ve(i) ? {\n        error: i.error\n      } : {\n        result: i.result\n      }, this.records.set(s.id, s), this.events.emit(C.updated, s));\n    }, this.get = async (i, s) => (this.isInitialized(), this.logger.debug(\"Getting record\"), this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic: i,\n      id: s\n    }), await this.getRecord(s)), this.delete = (i, s) => {\n      this.isInitialized(), this.logger.debug(\"Deleting record\"), this.logger.trace({\n        type: \"method\",\n        method: \"delete\",\n        id: s\n      }), this.values.forEach(n => {\n        if (n.topic === i) {\n          if (typeof s < \"u\" && n.id !== s) return;\n          this.records.delete(n.id), this.events.emit(C.deleted, n);\n        }\n      });\n    }, this.exists = async (i, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i : !1), this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = w(t, this.name);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get size() {\n    return this.records.size;\n  }\n  get keys() {\n    return Array.from(this.records.keys());\n  }\n  get values() {\n    return Array.from(this.records.values());\n  }\n  get pending() {\n    const e = [];\n    return this.values.forEach(t => {\n      if (typeof t.response < \"u\") return;\n      const i = {\n        topic: t.topic,\n        request: we(t.request.method, t.request.params, t.id),\n        chainId: t.chainId\n      };\n      return e.push(i);\n    }), e;\n  }\n  async setJsonRpcRecords(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getJsonRpcRecords() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  getRecord(e) {\n    this.isInitialized();\n    const t = this.records.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw new Error(i);\n    }\n    return t;\n  }\n  async persist() {\n    await this.setJsonRpcRecords(this.values), this.events.emit(C.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getJsonRpcRecords();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.records.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        records: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);\n    }\n  }\n  registerEventListeners() {\n    this.events.on(C.created, e => {\n      const t = C.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(C.updated, e => {\n      const t = C.updated;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    }), this.events.on(C.deleted, e => {\n      const t = C.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        record: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nclass St extends $t {\n  constructor(e, t) {\n    super(e, t), this.core = e, this.logger = t, this.expirations = new Map(), this.events = new A(), this.name = ut, this.version = lt, this.cached = [], this.initialized = !1, this.storagePrefix = P, this.init = async () => {\n      this.initialized || (this.logger.trace(\"Initialized\"), await this.restore(), this.cached.forEach(i => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);\n    }, this.has = i => {\n      try {\n        const s = this.formatTarget(i);\n        return typeof this.getExpiration(s) < \"u\";\n      } catch {\n        return !1;\n      }\n    }, this.set = (i, s) => {\n      this.isInitialized();\n      const n = this.formatTarget(i),\n        a = {\n          target: n,\n          expiry: s\n        };\n      this.expirations.set(n, a), this.checkExpiry(n, a), this.events.emit(m.created, {\n        target: n,\n        expiration: a\n      });\n    }, this.get = i => {\n      this.isInitialized();\n      const s = this.formatTarget(i);\n      return this.getExpiration(s);\n    }, this.del = i => {\n      if (this.isInitialized(), this.has(i)) {\n        const s = this.formatTarget(i),\n          n = this.getExpiration(s);\n        this.expirations.delete(s), this.events.emit(m.deleted, {\n          target: s,\n          expiration: n\n        });\n      }\n    }, this.on = (i, s) => {\n      this.events.on(i, s);\n    }, this.once = (i, s) => {\n      this.events.once(i, s);\n    }, this.off = (i, s) => {\n      this.events.off(i, s);\n    }, this.removeListener = (i, s) => {\n      this.events.removeListener(i, s);\n    }, this.logger = w(t, this.name);\n  }\n  get context() {\n    return v(this.logger);\n  }\n  get storageKey() {\n    return this.storagePrefix + this.version + \"//\" + this.name;\n  }\n  get length() {\n    return this.expirations.size;\n  }\n  get keys() {\n    return Array.from(this.expirations.keys());\n  }\n  get values() {\n    return Array.from(this.expirations.values());\n  }\n  formatTarget(e) {\n    if (typeof e == \"string\") return ci(e);\n    if (typeof e == \"number\") return ui(e);\n    const {\n      message: t\n    } = c(\"UNKNOWN_TYPE\", `Target type: ${typeof e}`);\n    throw new Error(t);\n  }\n  async setExpirations(e) {\n    await this.core.storage.setItem(this.storageKey, e);\n  }\n  async getExpirations() {\n    return await this.core.storage.getItem(this.storageKey);\n  }\n  async persist() {\n    await this.setExpirations(this.values), this.events.emit(m.sync);\n  }\n  async restore() {\n    try {\n      const e = await this.getExpirations();\n      if (typeof e > \"u\" || !e.length) return;\n      if (this.expirations.size) {\n        const {\n          message: t\n        } = c(\"RESTORE_WILL_OVERRIDE\", this.name);\n        throw this.logger.error(t), new Error(t);\n      }\n      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        expirations: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);\n    }\n  }\n  getExpiration(e) {\n    const t = this.expirations.get(e);\n    if (!t) {\n      const {\n        message: i\n      } = c(\"NO_MATCHING_KEY\", `${this.name}: ${e}`);\n      throw this.logger.error(i), new Error(i);\n    }\n    return t;\n  }\n  checkExpiry(e, t) {\n    const {\n      expiry: i\n    } = t;\n    be(i) - Date.now() <= 0 && this.expire(e, t);\n  }\n  expire(e, t) {\n    this.expirations.delete(e), this.events.emit(m.expired, {\n      target: e,\n      expiration: t\n    });\n  }\n  checkExpirations() {\n    this.expirations.forEach((e, t) => this.checkExpiry(t, e));\n  }\n  registerEventListeners() {\n    this.core.heartbeat.on(G.pulse, () => this.checkExpirations()), this.events.on(m.created, e => {\n      const t = m.created;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(m.expired, e => {\n      const t = m.expired;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    }), this.events.on(m.deleted, e => {\n      const t = m.deleted;\n      this.logger.info(`Emitting ${t}`), this.logger.debug({\n        type: \"event\",\n        event: t,\n        data: e\n      }), this.persist();\n    });\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: e\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(e);\n    }\n  }\n}\nvar cr = Object.defineProperty,\n  Tt = Object.getOwnPropertySymbols,\n  ur = Object.prototype.hasOwnProperty,\n  lr = Object.prototype.propertyIsEnumerable,\n  Pt = (r, e, t) => e in r ? cr(r, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : r[e] = t,\n  xt = (r, e) => {\n    for (var t in e || (e = {})) ur.call(e, t) && Pt(r, t, e[t]);\n    if (Tt) for (var t of Tt(e)) lr.call(e, t) && Pt(r, t, e[t]);\n    return r;\n  };\nclass V extends kt {\n  constructor(e) {\n    super(e), this.protocol = ne, this.version = Ke, this.name = B, this.events = new A(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e?.projectId;\n    const t = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : ce(ue({\n      level: e?.logger || $e.logger\n    }));\n    this.logger = w(t, this.name), this.heartbeat = new zt(), this.crypto = new gt(this, this.logger, e?.keychain), this.history = new Rt(this, this.logger), this.expirer = new St(this, this.logger), this.storage = e != null && e.storage ? e.storage : new At(xt(xt({}, ke), e?.storageOptions)), this.relayer = new ft({\n      core: this,\n      logger: this.logger,\n      relayUrl: e?.relayUrl,\n      projectId: this.projectId\n    }), this.pairing = new _t(this, this.logger);\n  }\n  static async init(e) {\n    const t = new V(e);\n    return await t.initialize(), t;\n  }\n  get context() {\n    return v(this.logger);\n  }\n  async start() {\n    this.initialized || (await this.initialize());\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info(\"Core Initialization Success\");\n    } catch (e) {\n      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;\n    }\n  }\n}\nconst dr = V;\nexport { B as CORE_CONTEXT, $e as CORE_DEFAULT, ne as CORE_PROTOCOL, ke as CORE_STORAGE_OPTIONS, P as CORE_STORAGE_PREFIX, Ke as CORE_VERSION, ae as CRYPTO_CLIENT_SEED, Be as CRYPTO_CONTEXT, je as CRYPTO_JWT_TTL, dr as Core, gt as Crypto, ut as EXPIRER_CONTEXT, Js as EXPIRER_DEFAULT_TTL, m as EXPIRER_EVENTS, lt as EXPIRER_STORAGE_VERSION, St as Expirer, ht as HISTORY_CONTEXT, C as HISTORY_EVENTS, ct as HISTORY_STORAGE_VERSION, Rt as JsonRpcHistory, Ve as KEYCHAIN_CONTEXT, qe as KEYCHAIN_STORAGE_VERSION, dt as KeyChain, Ge as MESSAGES_CONTEXT, Ye as MESSAGES_STORAGE_VERSION, pt as MessageTracker, at as PAIRING_CONTEXT, Ys as PAIRING_DEFAULT_TTL, N as PAIRING_RPC_OPTS, ot as PAIRING_STORAGE_VERSION, nt as PENDING_SUB_RESOLUTION_TIMEOUT, He as PUBLISHER_CONTEXT, Je as PUBLISHER_DEFAULT_TTL, _t as Pairing, Qe as RELAYER_CONTEXT, We as RELAYER_DEFAULT_LOGGER, Xe as RELAYER_DEFAULT_PROTOCOL, Ze as RELAYER_DEFAULT_RELAY_URL, D as RELAYER_EVENTS, M as RELAYER_PROVIDER_EVENTS, oe as RELAYER_RECONNECT_TIMEOUT, tt as RELAYER_SDK_VERSION, qs as RELAYER_STORAGE_OPTIONS, et as RELAYER_SUBSCRIBER_SUFFIX, ft as Relayer, it as STORE_STORAGE_VERSION, st as SUBSCRIBER_CONTEXT, Gs as SUBSCRIBER_DEFAULT_TTL, I as SUBSCRIBER_EVENTS, rt as SUBSCRIBER_STORAGE_VERSION, Ct as Store, bt as Subscriber, V as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}