{"ast":null,"code":"import ie from \"pino\";\nimport { RELAYER_DEFAULT_PROTOCOL as ne, RELAYER_EVENTS as re, EXPIRER_EVENTS as oe, Store as $, Core as ae } from \"@walletconnect/core\";\nimport { getDefaultLoggerOptions as ce, generateChildLogger as le, getLoggerContext as pe } from \"@walletconnect/logger\";\nimport { IEngine as he, ISignClient as de } from \"@walletconnect/types\";\nimport { TYPE_1 as ge, createDelayedPromise as q, engineEvent as p, getInternalError as c, calcExpiry as I, isValidObject as k, getRequiredNamespacesFromNamespaces as we, getSdkError as _, isSessionCompatible as me, isExpired as f, isValidParams as m, isUndefined as X, isValidRequiredNamespaces as ue, isValidRelays as ye, isValidNamespaces as M, isConformingNamespaces as J, isValidString as D, isValidErrorReason as Se, isValidRelay as Ee, isValidController as Ie, isValidNamespacesChainId as H, isValidRequest as _e, isValidNamespacesRequest as Re, isValidRequestExpiry as Ne, isValidResponse as qe, isValidEvent as fe, isValidNamespacesEvent as ve, parseExpirerTarget as Pe, isValidId as Ve, getAppMetadata as Oe } from \"@walletconnect/utils\";\nimport Te, { EventEmitter as xe } from \"events\";\nimport { THIRTY_DAYS as De, SEVEN_DAYS as F, FIVE_MINUTES as u, ONE_DAY as v, THIRTY_SECONDS as Q } from \"@walletconnect/time\";\nimport { isJsonRpcResult as R, isJsonRpcError as N, formatJsonRpcRequest as Ae, formatJsonRpcResult as Ce, formatJsonRpcError as Le, isJsonRpcRequest as be, isJsonRpcResponse as Ge } from \"@walletconnect/jsonrpc-utils\";\nconst U = \"wc\",\n  K = 2,\n  z = \"client\",\n  A = `${U}@${K}:${z}:`,\n  C = {\n    name: z,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  $e = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  Me = {\n    database: \":memory:\"\n  },\n  Ue = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Ke = \"history\",\n  ze = \"0.3\",\n  B = \"proposal\",\n  je = De,\n  Z = \"session\",\n  T = F,\n  W = \"engine\",\n  P = {\n    wc_sessionPropose: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: u,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: v,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: v,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: v,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: v,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: v,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: v,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: Q,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: Q,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  L = {\n    min: u,\n    max: F\n  },\n  ee = \"request\";\nvar Ye = Object.defineProperty,\n  ke = Object.defineProperties,\n  Xe = Object.getOwnPropertyDescriptors,\n  se = Object.getOwnPropertySymbols,\n  Je = Object.prototype.hasOwnProperty,\n  He = Object.prototype.propertyIsEnumerable,\n  te = (h, n, e) => n in h ? Ye(h, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : h[n] = e,\n  y = (h, n) => {\n    for (var e in n || (n = {})) Je.call(n, e) && te(h, e, n[e]);\n    if (se) for (var e of se(n)) He.call(n, e) && te(h, e, n[e]);\n    return h;\n  },\n  j = (h, n) => ke(h, Xe(n));\nclass Fe extends he {\n  constructor(n) {\n    var _this;\n    (super(n), _this = this), this.name = W, this.events = new Te(), this.initialized = !1, this.ignoredPayloadTypes = [ge], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(P)\n      }), this.initialized = !0);\n    }, this.connect = async e => {\n      this.isInitialized(), await this.isValidConnect(e);\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        relays: i\n      } = e;\n      let r = s,\n        o,\n        a = !1;\n      if (r && (a = this.client.core.pairing.pairings.get(r).active), !r || !a) {\n        const {\n          topic: E,\n          uri: g\n        } = await this.client.core.pairing.create();\n        r = E, o = g;\n      }\n      const l = await this.client.core.crypto.generateKeyPair(),\n        d = {\n          requiredNamespaces: t,\n          relays: i ?? [{\n            protocol: ne\n          }],\n          proposer: {\n            publicKey: l,\n            metadata: this.client.metadata\n          }\n        },\n        {\n          reject: S,\n          resolve: w,\n          done: V\n        } = q();\n      if (this.events.once(p(\"session_connect\"), async _ref => {\n        let {\n          error: E,\n          session: g\n        } = _ref;\n        if (E) S(E);else if (g) {\n          g.self.publicKey = l;\n          const O = j(y({}, g), {\n            requiredNamespaces: g.requiredNamespaces\n          });\n          await this.client.session.set(g.topic, O), await this.setExpiry(g.topic, g.expiry), r && (await this.client.core.pairing.updateMetadata({\n            topic: r,\n            metadata: g.peer.metadata\n          })), w(O);\n        }\n      }), !r) {\n        const {\n          message: E\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${r}`);\n        throw new Error(E);\n      }\n      const x = await this.sendRequest(r, \"wc_sessionPropose\", d),\n        G = I(u);\n      return await this.setProposal(x, y({\n        id: x,\n        expiry: G\n      }, d)), {\n        uri: o,\n        approval: V\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i\n        } = e,\n        r = this.client.proposal.get(s);\n      let {\n        pairingTopic: o,\n        proposer: a,\n        requiredNamespaces: l\n      } = r;\n      k(l) || (l = we(i, \"approve()\"), this.client.proposal.set(s, j(y({}, r), {\n        requiredNamespaces: l\n      })));\n      const d = await this.client.core.crypto.generateKeyPair(),\n        S = a.publicKey,\n        w = await this.client.core.crypto.generateSharedKey(d, S),\n        V = {\n          relay: {\n            protocol: t ?? \"irn\"\n          },\n          namespaces: i,\n          requiredNamespaces: l,\n          controller: {\n            publicKey: d,\n            metadata: this.client.metadata\n          },\n          expiry: I(T)\n        };\n      await this.client.core.relayer.subscribe(w);\n      const x = await this.sendRequest(w, \"wc_sessionSettle\", V),\n        {\n          done: G,\n          resolve: E,\n          reject: g\n        } = q();\n      this.events.once(p(\"session_approve\", x), _ref2 => {\n        let {\n          error: Y\n        } = _ref2;\n        Y ? g(Y) : E(this.client.session.get(w));\n      });\n      const O = j(y({}, V), {\n        topic: w,\n        acknowledged: !1,\n        self: V.controller,\n        peer: {\n          publicKey: a.publicKey,\n          metadata: a.metadata\n        },\n        controller: d\n      });\n      return await this.client.session.set(w, O), await this.setExpiry(w, I(T)), o && (await this.client.core.pairing.updateMetadata({\n        topic: o,\n        metadata: O.peer.metadata\n      })), o && s && (await this.sendResult(s, o, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: d\n      }), await this.client.proposal.delete(s, _(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: o\n      })), {\n        topic: w,\n        acknowledged: G\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, _(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: r,\n          resolve: o,\n          reject: a\n        } = q();\n      return this.events.once(p(\"session_update\", i), _ref3 => {\n        let {\n          error: l\n        } = _ref3;\n        l ? a(l) : o();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: r\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: r,\n          reject: o\n        } = q();\n      return this.events.once(p(\"session_extend\", t), _ref4 => {\n        let {\n          error: a\n        } = _ref4;\n        a ? o(a) : r();\n      }), await this.setExpiry(s, I(T)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: r\n        } = e,\n        o = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, r),\n        {\n          done: a,\n          resolve: l,\n          reject: d\n        } = q(r);\n      return this.events.once(p(\"session_request\", o), _ref5 => {\n        let {\n          error: S,\n          result: w\n        } = _ref5;\n        S ? d(S) : l(w);\n      }), await a();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      R(t) ? await this.sendResult(i, s, t.result) : N(t) && (await this.sendError(i, s, t.error)), this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      });\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: r,\n            reject: o\n          } = q();\n        this.events.once(p(\"session_ping\", t), _ref6 => {\n          let {\n            error: a\n          } = _ref6;\n          a ? o(a) : r();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      this.client.session.keys.includes(s) ? (await this.sendRequest(s, \"wc_sessionDelete\", _(\"USER_DISCONNECTED\")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => me(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.session.delete(e, _(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.deleteSymKey(e), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, _(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async function (e, s) {\n      let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      await Promise.all([_this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : _this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = P.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: r\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: r\n      }), s && this.client.core.expirer.set(t, I(s));\n    }, this.sendRequest = async (e, s, t, i) => {\n      const r = Ae(s, t),\n        o = await this.client.core.crypto.encode(e, r),\n        a = P[s].req;\n      return i && (a.ttl = i), this.client.core.history.set(e, r), this.client.core.relayer.publish(e, o, a), r.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = Ce(e, t),\n        r = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = P[o.request.method].res;\n      this.client.core.relayer.publish(s, r, a), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = Le(e, t),\n        r = await this.client.core.crypto.encode(s, i),\n        o = await this.client.core.history.get(s, e),\n        a = P[o.request.method].res;\n      this.client.core.relayer.publish(s, r, a), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        f(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        f(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(y({}, s.params));\n        const r = I(u),\n          o = y({\n            id: i,\n            pairingTopic: e,\n            expiry: r\n          }, t);\n        await this.setProposal(i, o), this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: o\n        });\n      } catch (r) {\n        await this.sendError(i, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (R(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const r = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: r\n        });\n        const o = r.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: o\n        });\n        const a = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: a\n        });\n        const l = await this.client.core.crypto.generateSharedKey(o, a);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const d = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: d\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else N(s) && (await this.client.proposal.delete(t, _(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: r,\n            controller: o,\n            expiry: a,\n            namespaces: l,\n            requiredNamespaces: d\n          } = s.params,\n          S = {\n            topic: e,\n            relay: r,\n            expiry: a,\n            namespaces: l,\n            acknowledged: !0,\n            requiredNamespaces: d,\n            controller: o.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: o.publicKey,\n              metadata: o.metadata\n            }\n          };\n        await this.sendResult(s.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: S\n        });\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", t), {})) : N(s) && (await this.client.session.delete(e, _(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(y({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (r) {\n        await this.sendError(i, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_update\", t), {}) : N(s) && this.events.emit(p(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, I(T)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_extend\", t), {}) : N(s) && this.events.emit(p(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        R(s) ? this.events.emit(p(\"session_ping\", t), {}) : N(s) && this.events.emit(p(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await this.sendResult(t, e, !0), await this.deleteSession(e), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(y({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        }), this.client.events.emit(\"session_request\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_request\", t), {\n        result: s.result\n      }) : N(s) && this.events.emit(p(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(y({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (r) {\n        await this.sendError(t, e, r), this.client.logger.error(r);\n      }\n    }, this.isValidConnect = async e => {\n      if (!m(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(o);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        relays: i\n      } = e;\n      if (X(s) || (await this.isValidPairingTopic(s)), !X(t) && k(t) === 0) return;\n      const r = ue(t, \"connect()\");\n      if (r) throw new Error(r.message);\n      if (!ye(i, !0)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${i}`);\n        throw new Error(o);\n      }\n    }, this.isValidApprove = async e => {\n      if (!m(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i\n      } = e;\n      await this.isValidProposalId(s);\n      const r = this.client.proposal.get(s),\n        o = M(t, \"approve()\");\n      if (o) throw new Error(o.message);\n      const a = J(r.requiredNamespaces, t, \"update()\");\n      if (a) throw new Error(a.message);\n      if (!D(i, !0)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(l);\n      }\n    }, this.isValidReject = async e => {\n      if (!m(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !Se(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!m(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: r\n      } = e;\n      if (!Ee(s)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const o = Ie(t, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      const a = M(i, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      if (f(r)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!m(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        r = M(t, \"update()\");\n      if (r) throw new Error(r.message);\n      const o = J(i.requiredNamespaces, t, \"update()\");\n      if (o) throw new Error(o.message);\n    }, this.isValidExtend = async e => {\n      if (!m(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!m(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: r\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: o\n      } = this.client.session.get(s);\n      if (!H(o, i)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!_e(t)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!Re(o, i, t.method)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(a);\n      }\n      if (r && !Ne(r, L)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `request() expiry: ${r}. Expiry must be a number (in seconds) between ${L.min} and ${L.max}`);\n        throw new Error(a);\n      }\n    }, this.isValidRespond = async e => {\n      if (!m(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !qe(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!m(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!m(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: r\n      } = this.client.session.get(s);\n      if (!H(r, i)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!fe(t)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!ve(r, i, t.name)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!m(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: n\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(n);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(re.message, async n => {\n      const {\n        topic: e,\n        message: s\n      } = n;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      be(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n        topic: e,\n        payload: t\n      })) : Ge(t) && (await this.client.core.history.resolve(t), this.onRelayEventResponse({\n        topic: e,\n        payload: t\n      }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(oe.expired, async n => {\n      const {\n        topic: e,\n        id: s\n      } = Pe(n.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, c(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0));\n    });\n  }\n  isValidPairingTopic(n) {\n    if (!D(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.core.pairing.pairings.get(n).expiry)) {\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(n) {\n    if (!D(n, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.session.get(n).expiry)) {\n      await this.deleteSession(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(n) {\n    if (this.client.session.keys.includes(n)) await this.isValidSessionTopic(n);else if (this.client.core.pairing.pairings.keys.includes(n)) this.isValidPairingTopic(n);else if (D(n, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${n}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${n}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(n) {\n    if (!Ve(n)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${n}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(n)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${n}`);\n      throw new Error(e);\n    }\n    if (f(this.client.proposal.get(n).expiry)) {\n      await this.deleteProposal(n);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${n}`);\n      throw new Error(e);\n    }\n  }\n}\nclass Qe extends $ {\n  constructor(n, e) {\n    super(n, e, B, A), this.core = n, this.logger = e;\n  }\n}\nclass Be extends $ {\n  constructor(n, e) {\n    super(n, e, Z, A), this.core = n, this.logger = e;\n  }\n}\nclass Ze extends $ {\n  constructor(n, e) {\n    super(n, e, ee, A), this.core = n, this.logger = e;\n  }\n}\nclass b extends de {\n  constructor(n) {\n    super(n), this.protocol = U, this.version = K, this.name = C.name, this.events = new xe(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = n?.name || C.name, this.metadata = n?.metadata || Oe();\n    const e = typeof n?.logger < \"u\" && typeof n?.logger != \"string\" ? n.logger : ie(ce({\n      level: n?.logger || C.logger\n    }));\n    this.core = n?.core || new ae(n), this.logger = le(e, this.name), this.session = new Be(this.core, this.logger), this.proposal = new Qe(this.core, this.logger), this.pendingRequest = new Ze(this.core, this.logger), this.engine = new Fe(this);\n  }\n  static async init(n) {\n    const e = new b(n);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return pe(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.logger.info(\"SignClient Initialization Success\");\n    } catch (n) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(n.message), n;\n    }\n  }\n}\nconst We = b;\nexport { W as ENGINE_CONTEXT, P as ENGINE_RPC_OPTS, Ke as HISTORY_CONTEXT, Ue as HISTORY_EVENTS, ze as HISTORY_STORAGE_VERSION, B as PROPOSAL_CONTEXT, je as PROPOSAL_EXPIRY, ee as REQUEST_CONTEXT, Z as SESSION_CONTEXT, T as SESSION_EXPIRY, L as SESSION_REQUEST_EXPIRY_BOUNDARIES, z as SIGN_CLIENT_CONTEXT, C as SIGN_CLIENT_DEFAULT, $e as SIGN_CLIENT_EVENTS, U as SIGN_CLIENT_PROTOCOL, Me as SIGN_CLIENT_STORAGE_OPTIONS, A as SIGN_CLIENT_STORAGE_PREFIX, K as SIGN_CLIENT_VERSION, We as SignClient, b as default };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}