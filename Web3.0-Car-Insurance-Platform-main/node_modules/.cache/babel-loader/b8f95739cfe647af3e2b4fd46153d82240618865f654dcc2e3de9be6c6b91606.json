{"ast":null,"code":"import { proxy as p, subscribe as f } from \"valtio/vanilla\";\nimport { Buffer as O } from \"buffer\";\nconst n = p({\n    selectedChain: void 0,\n    chains: void 0,\n    standaloneChains: void 0,\n    standaloneUri: void 0,\n    address: void 0,\n    profileName: void 0,\n    profileAvatar: void 0,\n    profileLoading: !1,\n    balanceLoading: !1,\n    balance: void 0,\n    isConnected: !1,\n    isStandalone: !1,\n    isCustomDesktop: !1,\n    isCustomMobile: !1,\n    isExplorer: !1,\n    isDataLoaded: !1,\n    isUiLoaded: !1\n  }),\n  a = {\n    state: n,\n    subscribe(e) {\n      return f(n, () => e(n));\n    },\n    setChains(e) {\n      n.chains = e;\n    },\n    setStandaloneChains(e) {\n      n.standaloneChains = e;\n    },\n    setStandaloneUri(e) {\n      n.standaloneUri = e;\n    },\n    getSelectedChain() {\n      const e = I.client().getNetwork().chain;\n      return e && (n.selectedChain = e), n.selectedChain;\n    },\n    setSelectedChain(e) {\n      n.selectedChain = e;\n    },\n    setIsStandalone(e) {\n      n.isStandalone = e;\n    },\n    setIsCustomDesktop(e) {\n      n.isCustomDesktop = e;\n    },\n    setIsCustomMobile(e) {\n      n.isCustomMobile = e;\n    },\n    setIsExplorer(e) {\n      n.isExplorer = e;\n    },\n    getAccount() {\n      const e = I.client().getAccount();\n      n.address = e.address, n.isConnected = e.isConnected;\n    },\n    setAddress(e) {\n      n.address = e;\n    },\n    setIsConnected(e) {\n      n.isConnected = e;\n    },\n    setProfileName(e) {\n      n.profileName = e;\n    },\n    setProfileAvatar(e) {\n      n.profileAvatar = e;\n    },\n    setProfileLoading(e) {\n      n.profileLoading = e;\n    },\n    setBalanceLoading(e) {\n      n.balanceLoading = e;\n    },\n    setBalance(e) {\n      n.balance = e;\n    },\n    setIsDataLoaded(e) {\n      n.isDataLoaded = e;\n    },\n    setIsUiLoaded(e) {\n      n.isUiLoaded = e;\n    },\n    resetEnsProfile() {\n      n.profileName = void 0, n.profileAvatar = void 0;\n    },\n    resetBalance() {\n      n.balance = void 0;\n    },\n    resetAccount() {\n      n.address = void 0, a.resetEnsProfile(), a.resetBalance();\n    }\n  },\n  h = p({\n    initialized: !1,\n    ethereumClient: void 0\n  }),\n  I = {\n    setEthereumClient(e) {\n      !h.initialized && e && (h.ethereumClient = e, a.setChains(e.chains), h.initialized = !0);\n    },\n    client() {\n      if (h.ethereumClient) return h.ethereumClient;\n      throw new Error(\"ClientCtrl has no client set\");\n    }\n  },\n  c = {\n    WALLETCONNECT_DEEPLINK_CHOICE: \"WALLETCONNECT_DEEPLINK_CHOICE\",\n    isMobile() {\n      return typeof window < \"u\" ? Boolean(window.matchMedia(\"(pointer:coarse)\").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;\n    },\n    isAndroid() {\n      return c.isMobile() && navigator.userAgent.toLowerCase().includes(\"android\");\n    },\n    isEmptyObject(e) {\n      return Object.getPrototypeOf(e) === Object.prototype && Object.getOwnPropertyNames(e).length === 0 && Object.getOwnPropertySymbols(e).length === 0;\n    },\n    isHttpUrl(e) {\n      return e.startsWith(\"http://\") || e.startsWith(\"https://\");\n    },\n    formatNativeUrl(e, t, s) {\n      if (c.isHttpUrl(e)) return this.formatUniversalUrl(e, t, s);\n      let o = e;\n      o.includes(\"://\") || (o = e.replaceAll(\"/\", \"\").replaceAll(\":\", \"\"), o = `${o}://`), this.setWalletConnectDeepLink(o, s);\n      const l = encodeURIComponent(t);\n      return `${o}wc?uri=${l}`;\n    },\n    formatUniversalUrl(e, t, s) {\n      if (!c.isHttpUrl(e)) return this.formatNativeUrl(e, t, s);\n      let o = e;\n      e.endsWith(\"/\") && (o = e.slice(0, -1)), this.setWalletConnectDeepLink(o, s);\n      const l = encodeURIComponent(t);\n      return `${o}/wc?uri=${l}`;\n    },\n    async wait(e) {\n      return new Promise(t => {\n        setTimeout(t, e);\n      });\n    },\n    openHref(e) {\n      let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"_self\";\n      window.open(e, t, \"noreferrer noopener\");\n    },\n    setWalletConnectDeepLink(e, t) {\n      localStorage.setItem(c.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n        href: e,\n        name: t\n      }));\n    },\n    setWalletConnectAndroidDeepLink(e) {\n      const [t] = e.split(\"?\");\n      localStorage.setItem(c.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({\n        href: t,\n        name: \"Android\"\n      }));\n    },\n    removeWalletConnectDeepLink() {\n      localStorage.removeItem(c.WALLETCONNECT_DEEPLINK_CHOICE);\n    },\n    isNull(e) {\n      return e === null;\n    },\n    getWalletConnectVersion() {\n      const {\n        isStandalone: e\n      } = a.state;\n      let t = 1;\n      return e || (t = I.client().walletConnectVersion), t;\n    }\n  };\nfunction S() {\n  return typeof matchMedia < \"u\" && matchMedia(\"(prefers-color-scheme: dark)\").matches;\n}\nconst g = p({\n    projectId: void 0,\n    themeMode: S() ? \"dark\" : \"light\",\n    themeColor: \"default\",\n    themeBackground: c.isMobile() ? \"themeColor\" : \"gradient\",\n    themeZIndex: 89,\n    mobileWallets: void 0,\n    desktopWallets: void 0,\n    walletImages: void 0,\n    chainImages: void 0,\n    tokenImages: void 0,\n    standaloneChains: void 0,\n    enableStandaloneMode: !1,\n    enableNetworkView: !1,\n    defaultChain: void 0,\n    explorerAllowList: void 0,\n    explorerDenyList: void 0,\n    termsOfServiceUrl: void 0,\n    privacyPolicyUrl: void 0\n  }),\n  E = {\n    state: g,\n    subscribe(e) {\n      return f(g, () => e(g));\n    },\n    setConfig(e) {\n      var t, s, o, l;\n      if (a.setStandaloneChains(e.standaloneChains), a.setIsStandalone(Boolean((t = e.standaloneChains) == null ? void 0 : t.length) || Boolean(e.enableStandaloneMode)), a.setIsCustomMobile(Boolean((s = e.mobileWallets) == null ? void 0 : s.length)), a.setIsCustomDesktop(Boolean((o = e.desktopWallets) == null ? void 0 : o.length)), a.setIsExplorer(Boolean((l = e.projectId) == null ? void 0 : l.length)), e.defaultChain) a.setSelectedChain(e.defaultChain);else if (!a.state.isStandalone) {\n        const u = I.client().getDefaultChain();\n        a.setSelectedChain(u);\n      }\n      Object.assign(g, e);\n    },\n    setThemeConfig(e) {\n      Object.assign(g, e);\n    }\n  },\n  L = \"https://explorer-api.walletconnect.com\";\nfunction y(e) {\n  const t = Object.fromEntries(Object.entries(e).filter(_ref => {\n    let [s, o] = _ref;\n    return typeof o < \"u\" && o !== null && o !== \"\";\n  }).map(_ref2 => {\n    let [s, o] = _ref2;\n    return [s, o.toString()];\n  }));\n  return new URLSearchParams(t).toString();\n}\nconst w = {\n    async fetchWallets(e, t) {\n      const s = y(t),\n        o = `${L}/v3/wallets?projectId=${e}&${s}`;\n      return (await fetch(o)).json();\n    },\n    formatImageUrl(e, t) {\n      return `${L}/v3/logo/lg/${t}?projectId=${e}`;\n    }\n  },\n  r = p({\n    wallets: {\n      listings: [],\n      total: 0,\n      page: 1\n    },\n    search: {\n      listings: [],\n      total: 0,\n      page: 1\n    },\n    previewWallets: [],\n    recomendedWallets: []\n  });\nfunction b() {\n  const {\n    projectId: e\n  } = E.state;\n  if (!e) throw new Error(\"projectId is required to work with explorer api\");\n  return e;\n}\nconst A = {\n    state: r,\n    async getPreviewWallets(e) {\n      const {\n        listings: t\n      } = await w.fetchWallets(b(), e);\n      return r.previewWallets = Object.values(t), r.previewWallets;\n    },\n    async getRecomendedWallets() {\n      const {\n        listings: e\n      } = await w.fetchWallets(b(), {\n        page: 1,\n        entries: 6\n      });\n      r.recomendedWallets = Object.values(e);\n    },\n    async getPaginatedWallets(e) {\n      const {\n          page: t,\n          search: s\n        } = e,\n        {\n          listings: o,\n          total: l\n        } = await w.fetchWallets(b(), e),\n        u = Object.values(o),\n        v = s ? \"search\" : \"wallets\";\n      return r[v] = {\n        listings: [...r[v].listings, ...u],\n        total: l,\n        page: t ?? 1\n      }, {\n        listings: u,\n        total: l\n      };\n    },\n    getImageUrl(e) {\n      return w.formatImageUrl(b(), e);\n    },\n    resetSearch() {\n      r.search = {\n        listings: [],\n        total: 0,\n        page: 1\n      };\n    }\n  },\n  i = p({\n    history: [\"ConnectWallet\"],\n    view: \"ConnectWallet\",\n    data: void 0\n  }),\n  m = {\n    state: i,\n    subscribe(e) {\n      return f(i, () => e(i));\n    },\n    push(e, t) {\n      e !== i.view && (i.view = e, t && (i.data = t), i.history.push(e));\n    },\n    replace(e) {\n      i.view = e, i.history = [e];\n    },\n    goBack() {\n      if (i.history.length > 1) {\n        i.history.pop();\n        const [e] = i.history.slice(-1);\n        i.view = e;\n      }\n    }\n  },\n  C = p({\n    open: !1\n  }),\n  k = {\n    state: C,\n    subscribe(e) {\n      return f(C, () => e(C));\n    },\n    async open(e) {\n      return new Promise(t => {\n        const {\n            isConnected: s,\n            isStandalone: o,\n            isUiLoaded: l,\n            isDataLoaded: u\n          } = a.state,\n          {\n            enableNetworkView: v\n          } = E.state;\n        if (o ? (a.setStandaloneUri(e?.uri), a.setStandaloneChains(e?.standaloneChains), m.replace(\"ConnectWallet\")) : e != null && e.route ? m.replace(e.route) : s ? m.replace(\"Account\") : v ? m.replace(\"SelectNetwork\") : m.replace(\"ConnectWallet\"), l && u) C.open = !0, t();else {\n          const W = setInterval(() => {\n            a.state.isUiLoaded && a.state.isDataLoaded && (clearInterval(W), C.open = !0, t());\n          }, 200);\n        }\n      });\n    },\n    close() {\n      C.open = !1;\n    }\n  },\n  d = p({\n    open: !1,\n    message: \"\",\n    variant: \"success\"\n  }),\n  P = {\n    state: d,\n    subscribe(e) {\n      return f(d, () => e(d));\n    },\n    openToast(e, t) {\n      d.open = !0, d.message = e, d.variant = t;\n    },\n    closeToast() {\n      d.open = !1;\n    }\n  };\ntypeof window < \"u\" && (window.Buffer || (window.Buffer = O), window.global || (window.global = window), window.process || (window.process = {\n  env: {}\n}));\nexport { I as ClientCtrl, E as ConfigCtrl, c as CoreUtil, A as ExplorerCtrl, k as ModalCtrl, a as OptionsCtrl, m as RouterCtrl, P as ToastCtrl };\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}