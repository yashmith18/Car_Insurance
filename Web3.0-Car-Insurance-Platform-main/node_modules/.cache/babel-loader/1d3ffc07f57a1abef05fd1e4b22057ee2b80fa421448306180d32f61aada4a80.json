{"ast":null,"code":"const EthQuery = require('eth-query');\nconst pify = require('pify');\nconst BaseFilterWithHistory = require('./base-filter-history');\nconst {\n  bnToHex,\n  hexToInt,\n  incrementHexInt,\n  minBlockRef,\n  blockRefIsNumber\n} = require('./hexUtils');\nclass LogFilter extends BaseFilterWithHistory {\n  constructor(_ref) {\n    let {\n      provider,\n      params\n    } = _ref;\n    super();\n    this.type = 'log';\n    this.ethQuery = new EthQuery(provider);\n    this.params = Object.assign({\n      fromBlock: 'latest',\n      toBlock: 'latest',\n      address: undefined,\n      topics: []\n    }, params);\n    // normalize address parameter\n    if (this.params.address) {\n      // ensure array\n      if (!Array.isArray(this.params.address)) {\n        this.params.address = [this.params.address];\n      }\n      // ensure lowercase\n      this.params.address = this.params.address.map(address => address.toLowerCase());\n    }\n  }\n  async initialize(_ref2) {\n    let {\n      currentBlock\n    } = _ref2;\n    // resolve params.fromBlock\n    let fromBlock = this.params.fromBlock;\n    if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;\n    if ('earliest' === fromBlock) fromBlock = '0x0';\n    this.params.fromBlock = fromBlock;\n    // set toBlock for initial lookup\n    const toBlock = minBlockRef(this.params.toBlock, currentBlock);\n    const params = Object.assign({}, this.params, {\n      toBlock\n    });\n    // fetch logs and add to results\n    const newLogs = await this._fetchLogs(params);\n    this.addInitialResults(newLogs);\n  }\n  async update(_ref3) {\n    let {\n      oldBlock,\n      newBlock\n    } = _ref3;\n    // configure params for this update\n    const toBlock = newBlock;\n    let fromBlock;\n    // oldBlock is empty on first sync\n    if (oldBlock) {\n      fromBlock = incrementHexInt(oldBlock);\n    } else {\n      fromBlock = newBlock;\n    }\n    // fetch logs\n    const params = Object.assign({}, this.params, {\n      fromBlock,\n      toBlock\n    });\n    const newLogs = await this._fetchLogs(params);\n    const matchingLogs = newLogs.filter(log => this.matchLog(log));\n\n    // add to results\n    this.addResults(matchingLogs);\n  }\n  async _fetchLogs(params) {\n    const newLogs = await pify(cb => this.ethQuery.getLogs(params, cb))();\n    // add to results\n    return newLogs;\n  }\n  matchLog(log) {\n    // check if block number in bounds:\n    if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;\n    if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false;\n\n    // address is correct:\n    const normalizedLogAddress = log.address && log.address.toLowerCase();\n    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false;\n\n    // topics match:\n    // topics are position-dependant\n    // topics can be nested to represent `or` [[a || b], c]\n    // topics can be null, representing a wild card for that position\n    const topicsMatch = this.params.topics.every((topicPattern, index) => {\n      // pattern is longer than actual topics\n      let logTopic = log.topics[index];\n      if (!logTopic) return false;\n      logTopic = logTopic.toLowerCase();\n      // normalize subTopics\n      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];\n      // check for wild card\n      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);\n      if (subtopicsIncludeWildcard) return true;\n      subtopicsToMatch = subtopicsToMatch.map(topic => topic.toLowerCase());\n      // check each possible matching topic\n      const topicDoesMatch = subtopicsToMatch.includes(logTopic);\n      return topicDoesMatch;\n    });\n    return topicsMatch;\n  }\n}\nmodule.exports = LogFilter;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}