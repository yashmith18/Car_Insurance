{"ast":null,"code":"/**\n * A client library for the https://web3.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://web3.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { Web3Storage, File } from 'web3.storage'\n * const client = new Web3Storage({ token: API_TOKEN })\n *\n * const cid = await client.put([new File(['hello world'], 'hello.txt', { type: 'text/plain' })])\n * ```\n * @module\n */\nimport { transform } from 'streaming-iterables';\nimport pRetry, { AbortError } from 'p-retry';\nimport { pack } from 'ipfs-car/pack';\nimport { parseLinkHeader } from '@web3-storage/parse-link-header';\nimport { unpackStream } from 'ipfs-car/unpack';\nimport { TreewalkCarSplitter } from 'carbites/treewalk';\nimport { CarReader } from '@ipld/car';\nimport { filesFromPath, getFilesFromPath } from 'files-from-path';\nimport throttledQueue from 'throttled-queue';\nimport { fetch as _fetch, File, Blob, Blockstore } from './platform.js';\nconst MAX_PUT_RETRIES = 5;\nconst MAX_CONCURRENT_UPLOADS = 3;\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024 * 10; // chunk to ~10MB CARs\nconst MAX_BLOCK_SIZE = 1048576;\nconst MAX_CHUNK_SIZE = 104857600;\n// These match what is enforced server-side\nconst RATE_LIMIT_REQUESTS = 30;\nconst RATE_LIMIT_PERIOD = 10 * 1000;\n\n/** @typedef { import('./lib/interface.js').API } API */\n/** @typedef { import('./lib/interface.js').Status} Status */\n/** @typedef { import('./lib/interface.js').Upload} Upload */\n/** @typedef { import('./lib/interface.js').Service } Service */\n/** @typedef { import('./lib/interface.js').Web3File} Web3File */\n/** @typedef { import('./lib/interface.js').Filelike } Filelike */\n/** @typedef { import('./lib/interface.js').CIDString} CIDString */\n/** @typedef { import('./lib/interface.js').RequestOptions} RequestOptions */\n/** @typedef { import('./lib/interface.js').PutOptions} PutOptions */\n/** @typedef { import('./lib/interface.js').PutCarOptions} PutCarOptions */\n/** @typedef { import('./lib/interface.js').ListOptions} ListOptions */\n/** @typedef { import('./lib/interface.js').RateLimiter } RateLimiter */\n/** @typedef { import('./lib/interface.js').UnixFSEntry} UnixFSEntry */\n/** @typedef { import('./lib/interface.js').Web3Response} Web3Response */\n\n/**\n * Creates a rate limiter which limits at the same rate as is enforced\n * server-side, to allow the client to avoid exceeding the requests limit and\n * being blocked for 30 seconds.\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);\n  return () => throttle(() => {});\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the Web3Storage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter();\n\n/**\n * @implements Service\n */\nclass Web3Storage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { Web3Storage } from 'web3.storage'\n   * const client = new Web3Storage({ token: API_TOKEN })\n   * ```\n   *\n    @param {Service} options\n   */\n  constructor(_ref) {\n    let {\n      token,\n      endpoint = new URL('https://api.web3.storage'),\n      rateLimiter,\n      fetch = _fetch\n    } = _ref;\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token;\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint;\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter();\n    /**\n     * Optional custom fetch function. Defaults to global fetch in browsers or @web-std/fetch on node.\n     * @readonly\n     */\n    this.fetch = fetch;\n  }\n\n  /**\n   * @hidden\n   * @param {string} token\n   * @returns {Record<string, string>}\n   */\n  static headers(token) {\n    if (!token) throw new Error('missing token');\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'web3.storage/js'\n    };\n  }\n\n  /**\n   * @param {Service} service\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async put(_ref2, files) {\n    let {\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter,\n      fetch = _fetch\n    } = _ref2;\n    let {\n      onRootCidReady,\n      onStoredChunk,\n      maxRetries = MAX_PUT_RETRIES,\n      maxChunkSize = DEFAULT_CHUNK_SIZE,\n      wrapWithDirectory = true,\n      name,\n      signal\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n    const blockstore = new Blockstore();\n    try {\n      const {\n        out,\n        root\n      } = await pack({\n        input: Array.from(files).map(toImportCandidate),\n        blockstore,\n        wrapWithDirectory,\n        maxChunkSize: MAX_BLOCK_SIZE,\n        maxChildrenPerNode: 1024\n      });\n      onRootCidReady && onRootCidReady(root.toString());\n      const car = await CarReader.fromIterable(out);\n      return await Web3Storage.putCar({\n        endpoint,\n        token,\n        rateLimiter,\n        fetch\n      }, car, {\n        onStoredChunk,\n        maxRetries,\n        maxChunkSize,\n        name,\n        signal\n      });\n    } finally {\n      await blockstore.close();\n    }\n  }\n\n  /**\n   * @param {Service} service\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async putCar(_ref3, car) {\n    let {\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter,\n      fetch = _fetch\n    } = _ref3;\n    let {\n      name,\n      onStoredChunk,\n      maxRetries = MAX_PUT_RETRIES,\n      maxChunkSize = DEFAULT_CHUNK_SIZE,\n      decoders,\n      signal\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (maxChunkSize >= MAX_CHUNK_SIZE || maxChunkSize < MAX_BLOCK_SIZE) {\n      throw new Error('maximum chunk size must be less than 100MiB and greater than or equal to 1MB');\n    }\n    const targetSize = maxChunkSize;\n    const url = new URL('car', endpoint);\n    let headers = Web3Storage.headers(token);\n    if (name) {\n      headers = {\n        ...headers,\n        'X-Name': encodeURIComponent(name)\n      };\n    }\n    const roots = await car.getRoots();\n    if (roots[0] == null) {\n      throw new Error('missing root CID');\n    }\n    if (roots.length > 1) {\n      throw new Error('too many roots');\n    }\n    const carRoot = roots[0].toString();\n    const splitter = new TreewalkCarSplitter(car, targetSize, {\n      decoders\n    });\n\n    /**\n     * @param {AsyncIterable<Uint8Array>} car\n     * @returns {Promise<CIDString>}\n     */\n    const onCarChunk = async car => {\n      const carParts = [];\n      for await (const part of car) {\n        carParts.push(part);\n      }\n      const carFile = new Blob(carParts, {\n        type: 'application/vnd.ipld.car'\n      });\n      const res = await pRetry(async () => {\n        await rateLimiter();\n        /** @type {Response} */\n        let response;\n        try {\n          response = await fetch(url.toString(), {\n            method: 'POST',\n            headers,\n            body: carFile,\n            signal\n          });\n        } catch ( /** @type {any} */err) {\n          throw signal && signal.aborted ? new AbortError(err) : err;\n        }\n        /* c8 ignore next 3 */\n        if (response.status === 429) {\n          throw new Error('rate limited');\n        }\n        const res = await response.json();\n        if (!response.ok) {\n          throw new Error(res.message);\n        }\n        if (res.cid !== carRoot) {\n          throw new Error(`root CID mismatch, expected: ${carRoot}, received: ${res.cid}`);\n        }\n        return res.cid;\n      }, {\n        retries: maxRetries\n      });\n      onStoredChunk && onStoredChunk(carFile.size);\n      return res;\n    };\n    const upload = transform(MAX_CONCURRENT_UPLOADS, onCarChunk);\n    for await (const _ of upload(splitter.cars())) {} // eslint-disable-line\n    return carRoot;\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Web3Response | null>}\n   */\n  static async get(_ref4, cid) {\n    let {\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter,\n      fetch = _fetch\n    } = _ref4;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const url = new URL(`car/${cid}`, endpoint);\n    await rateLimiter();\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    });\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n    return toWeb3Response(res);\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  /* c8 ignore next 4 */\n  static async delete(_ref5, cid) {\n    let {\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter\n    } = _ref5;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    console.log('Not deleting', cid, endpoint, token, rateLimiter, options);\n    throw Error('.delete not implemented yet');\n  }\n\n  /**\n   * @param {Service} service\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<Status | undefined>}\n   */\n  static async status(_ref6, cid) {\n    let {\n      endpoint,\n      token,\n      rateLimiter = globalRateLimiter,\n      fetch = _fetch\n    } = _ref6;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const url = new URL(`status/${cid}`, endpoint);\n    await rateLimiter();\n    const res = await fetch(url.toString(), {\n      method: 'GET',\n      headers: Web3Storage.headers(token),\n      signal: options.signal\n    });\n    /* c8 ignore next 3 */\n    if (res.status === 429) {\n      throw new Error('rate limited');\n    }\n    if (res.status === 404) {\n      return undefined;\n    }\n    if (!res.ok) {\n      throw new Error(res.statusText);\n    }\n    return res.json();\n  }\n\n  /**\n   * @param {Service} service\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  static list(service) {\n    try {\n      let {\n        before = new Date().toISOString(),\n        maxResults = Infinity,\n        signal\n      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return async function* () {\n        /**\n         * @param {Service} service\n         * @param {{before: string, size: number}} opts\n         * @returns {Promise<Response>}\n         */\n        async function listPage(_ref7, _ref8) {\n          let {\n            endpoint,\n            token,\n            rateLimiter = globalRateLimiter,\n            fetch = _fetch\n          } = _ref7;\n          let {\n            before,\n            size\n          } = _ref8;\n          const search = new URLSearchParams({\n            before,\n            size: size.toString()\n          });\n          const url = new URL(`user/uploads?${search}`, endpoint);\n          await rateLimiter();\n          return fetch(url.toString(), {\n            method: 'GET',\n            headers: {\n              ...Web3Storage.headers(token),\n              'Access-Control-Request-Headers': 'Link'\n            },\n            signal\n          });\n        }\n        let count = 0;\n        const size = maxResults > 100 ? 100 : maxResults;\n        for await (const res of paginator(listPage, service, {\n          before,\n          size\n        })) {\n          if (!res.ok) {\n            /* c8 ignore next 3 */\n            if (res.status === 429) {\n              throw new Error('rate limited');\n            }\n\n            /* c8 ignore next 2 */\n            const errorMessage = await res.json();\n            throw new Error(`${res.status} ${res.statusText} ${errorMessage ? '- ' + errorMessage.message : ''}`);\n          }\n          const page = await res.json();\n          for (const upload of page) {\n            if (++count > maxResults) {\n              return;\n            }\n            yield upload;\n          }\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Uploads files to web3.storage. Files are hashed in the client and uploaded as a single\n   * [Content Addressed Archive(CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * const file = new File(['hello world'], 'hello.txt', { type: 'text/plain' })\n   * const cid = await client.put([file])\n   * ```\n   * @param {Iterable<Filelike>} files\n   * @param {PutOptions} [options]\n   */\n  put(files, options) {\n    return Web3Storage.put(this, files, options);\n  }\n\n  /**\n   * Uploads a CAR ([Content Addressed Archive](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)) file to web3.storage.\n   * Takes a CarReader interface from @ipld/car\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * @example\n   * ```js\n   * import fs from 'fs'\n   * import { Readable } from 'stream'\n   * import { CarReader, CarWriter } from '@ipld/car'\n   * import * as raw from 'multiformats/codecs/raw'\n   * import { CID } from 'multiformats/cid'\n   * import { sha256 } from 'multiformats/hashes/sha2'\n   *\n   * async function getCar() {\n   *    const bytes = new TextEncoder().encode('random meaningless bytes')\n   *    const hash = await sha256.digest(raw.encode(bytes))\n   *    const cid = CID.create(1, raw.code, hash)\n   *\n   *    // create the writer and set the header with a single root\n   *    const { writer, out } = await CarWriter.create([cid])\n   *    Readable.from(out).pipe(fs.createWriteStream('example.car'))\n    *    // store a new block, creates a new file entry in the CAR archive\n   *    await writer.put({ cid, bytes })\n   *    await writer.close()\n    *    const inStream = fs.createReadStream('example.car')\n   *    // read and parse the entire stream in one go, this will cache the contents of\n   *    // the car in memory so is not suitable for large files.\n   *    const reader = await CarReader.fromIterable(inStream)\n   *    return reader\n   * }\n   *\n   * const car = await getCar()\n   * const cid = await client.putCar(car)\n   * ```\n   * @param {import('@ipld/car/api').CarReader} car\n   * @param {PutCarOptions} [options]\n   */\n  putCar(car, options) {\n    return Web3Storage.putCar(this, car, options);\n  }\n\n  /**\n   * Fetch the Content Addressed Archive by its root CID.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  get(cid, options) {\n    return Web3Storage.get(this, cid, options);\n  }\n\n  /**\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  /* c8 ignore next 3 */\n  delete(cid, options) {\n    return Web3Storage.delete(this, cid, options);\n  }\n\n  /**\n   * Fetch info on Filecoin deals and IPFS pins that a given CID is replicated in.\n   * @param {CIDString} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return Web3Storage.status(this, cid, options);\n  }\n\n  /**\n   * Find all uploads for this account. Use a `for await...of` loop to fetch them all.\n   * @example\n   * Fetch all the uploads\n   * ```js\n   * const uploads = []\n   * for await (const item of client.list()) {\n   *    uploads.push(item)\n   * }\n   * ```\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\n   * @param {ListOptions} [opts]\n   * @returns {AsyncIterable<Upload>}\n   */\n  list(opts) {\n    return Web3Storage.list(this, opts);\n  }\n}\n\n/**\n * Map a UnixFSEntry to a File with a cid property.\n *\n * @param {UnixFSEntry} entry\n * @returns {Promise<Web3File>}\n */\nasync function toWeb3File(_ref9) {\n  let {\n    content,\n    path,\n    cid\n  } = _ref9;\n  const chunks = [];\n  for await (const chunk of content()) {\n    chunks.push(chunk);\n  }\n  const file = new File(chunks, toFilenameWithPath(path));\n  return Object.assign(file, {\n    cid: cid.toString()\n  });\n}\n\n/**\n * Trim the root cid from the path if there is anyting after it.\n * bafy...ic2q/path/to/pinpie.jpg => path/to/pinpie.jpg\n *         bafy...ic2q/pinpie.jpg => pinpie.jpg\n *                    bafk...52zy => bafk...52zy\n * @param {string} unixFsPath\n * @returns {string}\n */\nfunction toFilenameWithPath(unixFsPath) {\n  const slashIndex = unixFsPath.indexOf('/');\n  return slashIndex === -1 ? unixFsPath : unixFsPath.substring(slashIndex + 1);\n}\n\n/**\n * Add car unpacking smarts to the response object,\n * @param {Response} res\n * @returns {Web3Response}\n */\nfunction toWeb3Response(res) {\n  const response = Object.assign(res, {\n    unixFsIterator: async function* () {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .unixFsIterator`);\n      }\n      /* c8 ignore next 3 */\n      if (!res.body) {\n        throw new Error('No body on response');\n      }\n      const blockstore = new Blockstore();\n      try {\n        for await (const entry of unpackStream(res.body, {\n          blockstore\n        })) {\n          yield entry;\n        }\n      } finally {\n        await blockstore.close();\n      }\n    },\n    files: async () => {\n      if (!res.ok) {\n        throw new Error(`Response was not ok: ${res.status} ${res.statusText} - Check for { \"ok\": false } on the Response object before calling .files`);\n      }\n      const files = [];\n      // @ts-ignore we're using the enriched response here\n      for await (const entry of response.unixFsIterator()) {\n        if (entry.type === 'directory') {\n          continue;\n        }\n        const file = await toWeb3File(entry);\n        files.push(file);\n      }\n      return files;\n    }\n  });\n  return response;\n}\n\n/**\n * Convert the passed file to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is only created when needed.\n *\n * @param {Filelike} file\n */\nfunction toImportCandidate(file) {\n  /** @type {ReadableStream} */\n  let stream;\n  return {\n    path: file.name,\n    get content() {\n      stream = stream || file.stream();\n      return stream;\n    }\n  };\n}\n\n/**\n * Follow Link headers on a Response, to fetch all the things.\n *\n * @param {(service: Service, opts: any) => Promise<Response>} fn\n * @param {Service} service\n * @param {{}} opts\n */\nasync function* paginator(fn, service, opts) {\n  let res = await fn(service, opts);\n  yield res;\n  let link = parseLinkHeader(res.headers.get('Link') || '');\n  // @ts-ignore\n  while (link && link.next) {\n    // @ts-ignore\n    res = await fn(service, link.next);\n    yield res;\n    link = parseLinkHeader(res.headers.get('Link') || '');\n  }\n}\nexport { Web3Storage, File, Blob, filesFromPath, getFilesFromPath };\n\n/**\n * Just to verify API compatibility.\n * TODO: convert lib to a regular class that can be type checked.\n * @type {API}\n */\nconst api = Web3Storage;\nvoid api; // eslint-disable-line no-void","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}