{"ast":null,"code":"const MAX_HEADER_LENGTH = 2000;\nconst THROW_ON_MAX_HEADER_LENGTH_EXCEEDED = false;\nfunction hasRel(x) {\n  return x && x.rel;\n}\nfunction intoRels(acc, x) {\n  function splitRel(rel) {\n    acc[rel] = Object.assign({}, x, {\n      rel: rel\n    });\n  }\n  x.rel.split(/\\s+/).forEach(splitRel);\n  return acc;\n}\nfunction createObjects(acc, p) {\n  // rel=\"next\" => 1: rel 2: next\n  const m = p.match(/\\s*(.+)\\s*=\\s*\"?([^\"]+)\"?/);\n  if (m) acc[m[1]] = m[2];\n  return acc;\n}\nfunction parseLink(link) {\n  try {\n    const m = link.match(/<?([^>]*)>(.*)/);\n    const linkUrl = m[1];\n    const parts = m[2].split(';');\n    const qry = {};\n    // The origin is unused but it's required to parse relative URLs\n    const url = new URL(linkUrl, 'https://example.com');\n    for (const [key, value] of url.searchParams) {\n      qry[key] = value;\n    }\n    parts.shift();\n    let info = parts.reduce(createObjects, {});\n    info = Object.assign({}, qry, info);\n    info.url = linkUrl;\n    return info;\n  } catch {\n    return null;\n  }\n}\nfunction checkHeader(linkHeader, options) {\n  if (!linkHeader) return false;\n  options = options || {};\n  const maxHeaderLength = options.maxHeaderLength || MAX_HEADER_LENGTH;\n  const throwOnMaxHeaderLengthExceeded = options.throwOnMaxHeaderLengthExceeded || THROW_ON_MAX_HEADER_LENGTH_EXCEEDED;\n  if (linkHeader.length > maxHeaderLength) {\n    if (throwOnMaxHeaderLengthExceeded) {\n      throw new Error('Input string too long, it should be under ' + maxHeaderLength + ' characters.');\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nfunction parseLinkHeader(linkHeader, options) {\n  if (!checkHeader(linkHeader, options)) return null;\n  return linkHeader.split(/,\\s*</).map(parseLink).filter(hasRel).reduce(intoRels, {});\n}\nexport { parseLinkHeader };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}