{"ast":null,"code":"import { InjectedConnector } from \"./chunk-YUNHZJBB.js\";\nimport { __privateAdd, __privateGet, __privateSet, __publicField } from \"./chunk-5NCTPR6C.js\";\n\n// src/metaMask.ts\nimport { ConnectorNotFoundError, ResourceUnavailableError, UserRejectedRequestError, getClient } from \"@wagmi/core\";\nimport { getAddress } from \"ethers/lib/utils.js\";\nvar _UNSTABLE_shimOnConnectSelectAccount;\nvar MetaMaskConnector = class extends InjectedConnector {\n  constructor() {\n    let {\n      chains,\n      options: options_\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      name: \"MetaMask\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider() {\n        function getReady(ethereum) {\n          const isMetaMask = !!ethereum?.isMetaMask;\n          if (!isMetaMask) return;\n          if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;\n          if (ethereum.isAvalanche) return;\n          if (ethereum.isKuCoinWallet) return;\n          if (ethereum.isPortal) return;\n          if (ethereum.isTokenPocket) return;\n          if (ethereum.isTokenary) return;\n          return ethereum;\n        }\n        if (typeof window === \"undefined\") return;\n        if (window.ethereum?.providers) return window.ethereum.providers.find(getReady);\n        return getReady(window.ethereum);\n      },\n      ...options_\n    };\n    super({\n      chains,\n      options\n    });\n    __publicField(this, \"id\", \"metaMask\");\n    __privateAdd(this, _UNSTABLE_shimOnConnectSelectAccount, void 0);\n    __privateSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n      if (provider.on) {\n        provider.on(\"accountsChanged\", this.onAccountsChanged);\n        provider.on(\"chainChanged\", this.onChainChanged);\n        provider.on(\"disconnect\", this.onDisconnect);\n      }\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n      let account = null;\n      if (__privateGet(this, _UNSTABLE_shimOnConnectSelectAccount) && this.options?.shimDisconnect && !getClient().storage?.getItem(this.shimDisconnectKey)) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) try {\n          await provider.request({\n            method: \"wallet_requestPermissions\",\n            params: [{\n              eth_accounts: {}\n            }]\n          });\n          account = await this.getAccount();\n        } catch (error) {\n          if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n        }\n      }\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = getAddress(accounts[0]);\n      }\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n      if (this.options?.shimDisconnect) getClient().storage?.setItem(this.shimDisconnectKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n};\n_UNSTABLE_shimOnConnectSelectAccount = new WeakMap();\nexport { MetaMaskConnector };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}