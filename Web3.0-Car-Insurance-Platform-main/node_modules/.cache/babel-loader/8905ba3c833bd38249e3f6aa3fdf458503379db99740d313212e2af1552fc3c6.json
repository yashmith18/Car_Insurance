{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport fetch from \"cross-fetch\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { formatJsonRpcError, isHttpUrl, parseConnectionError } from \"@walletconnect/jsonrpc-utils\";\nconst DEFAULT_HTTP_HEADERS = {\n  Accept: \"application/json\",\n  \"Content-Type\": \"application/json\"\n};\nconst DEFAULT_HTTP_METHOD = \"POST\";\nconst DEFAULT_FETCH_OPTS = {\n  headers: DEFAULT_HTTP_HEADERS,\n  method: DEFAULT_HTTP_METHOD\n};\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\nexport class HttpConnection {\n  constructor(url) {\n    this.url = url;\n    this.events = new EventEmitter();\n    this.isAvailable = false;\n    this.registering = false;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    this.url = url;\n  }\n  get connected() {\n    return this.isAvailable;\n  }\n  get connecting() {\n    return this.registering;\n  }\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n  async open() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    await this.register(url);\n  }\n  async close() {\n    if (!this.isAvailable) {\n      throw new Error(\"Connection already closed\");\n    }\n    this.onClose();\n  }\n  async send(payload, context) {\n    if (!this.isAvailable) {\n      await this.register();\n    }\n    try {\n      const body = safeJsonStringify(payload);\n      const res = await fetch(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      const data = await res.json();\n      this.onPayload({\n        data\n      });\n    } catch (e) {\n      this.onError(payload.id, e);\n    }\n  }\n  async register() {\n    let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;\n    if (!isHttpUrl(url)) {\n      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (this.events.listenerCount(\"register_error\") >= currentMaxListeners || this.events.listenerCount(\"open\") >= currentMaxListeners) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", error => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.isAvailable === \"undefined\") {\n            return reject(new Error(\"HTTP connection is missing or invalid\"));\n          }\n          resolve();\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n    try {\n      const body = safeJsonStringify({\n        id: 1,\n        jsonrpc: \"2.0\",\n        method: \"test\",\n        params: []\n      });\n      await fetch(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), {\n        body\n      }));\n      this.onOpen();\n    } catch (e) {\n      const error = this.parseError(e);\n      this.events.emit(\"register_error\", error);\n      this.onClose();\n      throw error;\n    }\n  }\n  onOpen() {\n    this.isAvailable = true;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n  onClose() {\n    this.isAvailable = false;\n    this.registering = false;\n    this.events.emit(\"close\");\n  }\n  onPayload(e) {\n    if (typeof e.data === \"undefined\") return;\n    const payload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n  onError(id, e) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n  parseError(e) {\n    let url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;\n    return parseConnectionError(e, url, \"HTTP\");\n  }\n  resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n}\nexport default HttpConnection;\n//# sourceMappingURL=http.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}