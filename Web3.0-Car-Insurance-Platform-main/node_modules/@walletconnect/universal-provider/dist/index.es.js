import g from"pino";import f from"@walletconnect/sign-client";import{getSdkError as h,isValidArray as P}from"@walletconnect/utils";import{getDefaultLoggerOptions as w}from"@walletconnect/logger";import{JsonRpcProvider as c}from"@walletconnect/jsonrpc-provider";import p,{HttpConnection as I}from"@walletconnect/jsonrpc-http-connection";import C from"events";function y(s){var t;const e=(t=s[Object.keys(s)[0]])==null?void 0:t.chains[0];return[e.split(":")[0],e.split(":")[1]]}function r(s,t){let e;return t.rpcMap&&(e=t.rpcMap[O([s])]),e}function O(s){return Number(s[0].split(":")[1])}class E{constructor(t){this.name="eip155",this.namespace=t.namespace,this.client=t.client,this.events=t.events,this.httpProviders=this.createHttpProviders(),this.chainId=this.getDefaultChainId()}async request(t){var e;switch(t.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":{const i=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:"0x0";return this.setDefaultChain(parseInt(i,16).toString()),null}case"eth_chainId":return this.getDefaultChainId()}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){if(this.chainId=parseInt(t),!this.httpProviders[t]){const i=e||r(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit("chainChanged",this.chainId)}requestAccounts(){return this.getAccounts()}createHttpProvider(t,e){const i=e||r(t,this.namespace);return typeof i>"u"?void 0:new c(new I(i))}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return parseInt(t.split(":")[1])}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}}class ${constructor(t){this.name="solana",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||r(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||r(t,this.namespace);return typeof i>"u"?void 0:new c(new p(i))}}class q{constructor(t){this.name="cosmos",this.namespace=t.namespace,this.events=t.events,this.client=t.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getDefaultChainId(){if(this.chainId)return this.chainId;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const i=e||r(`${this.name}:${t}`,this.namespace);if(!i)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,i)}this.events.emit("chainChanged",this.chainId)}setHttpProvider(t,e){const i=this.createHttpProvider(t,e);i&&(this.httpProviders[t]=i)}createHttpProvider(t,e){const i=e||r(t,this.namespace);return typeof i>"u"?void 0:new c(new p(i))}}const d="error",b="wss://relay.walletconnect.com",H="wc",S="universal_provider",l=`${H}@${2}:${S}:`;var N=Object.defineProperty,A=Object.defineProperties,D=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,j=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable,v=(s,t,e)=>t in s?N(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,m=(s,t)=>{for(var e in t||(t={}))j.call(t,e)&&v(s,e,t[e]);if(u)for(var e of u(t))_.call(t,e)&&v(s,e,t[e]);return s},k=(s,t)=>A(s,D(t));class a{constructor(t){this.events=new C,this.rpcProviders={},this.providerOpts=t,this.logger=typeof t?.logger<"u"&&typeof t?.logger!="string"?t.logger:g(w({level:t?.logger||d}))}static async init(t){const e=new a(t);return await e.initialize(),e}async request(t,e){var i;const[n,o]=this.validateChain(e);return await this.getProvider(n).request({request:m({},t),chainId:`${n}:${o}`,topic:(i=this.session)==null?void 0:i.topic})}sendAsync(t,e,i){this.request(t,i).then(n=>e(null,n)).catch(n=>e(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Please call connect() before enable()");return await this.requestAccounts()}async disconnect(){if(!this.client)throw new Error("Sign Client not initialized");await this.client.disconnect({topic:this.session.topic,reason:h("USER_DISCONNECTED")})}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");const{namespaces:e}=t;return this.setNamespaces(e),this.createProviders(),await this.cleanupPendingPairings(),t.skipPairing===!0?void 0:await this.pair(t.pairingTopic)}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){const{uri:e,approval:i}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces});return e&&(this.uri=e,this.events.emit("display_uri",e)),this.session=await i(),this.onSessionUpdate(),this.session}setDefaultChain(t,e){try{const[i,n]=this.validateChain(t);this.getProvider(i).setDefaultChain(n,e)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(){this.logger.info("Cleaning up inactive pairings...");const t=this.client.pairing.getAll({active:!1});P(t)&&(await Promise.all([t.map(e=>this.client.pairing.delete(e.topic,h("USER_DISCONNECTED"))),t.map(e=>this.client.core.relayer.unsubscribe(e.topic)),t.map(e=>this.client.core.expirer.del(e.topic))]),this.logger.info(`Inactive pairings cleared: ${t.length}`))}async checkStorage(){if(this.namespaces=await this.client.core.storage.getItem(`${l}/namespaces`)||{},this.namespaces&&this.createProviders(),this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.onSessionUpdate()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await f.init({logger:this.providerOpts.logger||d,relayUrl:this.providerOpts.relayUrl||b,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");Object.keys(this.namespaces).forEach(t=>{switch(t){case"eip155":this.rpcProviders[t]=new E({client:this.client,namespace:this.namespaces[t],events:this.events});break;case"solana":this.rpcProviders[t]=new $({client:this.client,namespace:this.namespaces[t],events:this.events});break;case"cosmos":this.rpcProviders[t]=new q({client:this.client,namespace:this.namespaces[t],events:this.events});break}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:e})=>{var i;const{namespaces:n}=e,o=(i=this.client)==null?void 0:i.session.get(t);this.session=k(m({},o),{namespaces:n}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})}),this.client.on("session_delete",()=>{this.events.emit("session_delete")})}getProvider(t){if(!this.rpcProviders[t])throw new Error(`Provider not found: ${t}`);return this.rpcProviders[t]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>this.getProvider(t).updateNamespace(this.session.namespaces[t]))}setNamespaces(t){if(!t||!Object.keys(t).length)throw new Error("Namespaces must be not empty");this.client.core.storage.setItem(`${l}/namespaces`,t),this.namespaces=t}validateChain(t){const[e,i]=t?.split(":")||["",""];if(e&&!Object.keys(this.namespaces).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);return!e||!i?y(this.namespaces):[e,i]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}}const R=a;export{R as UniversalProvider,a as default};
//# sourceMappingURL=index.es.js.map
